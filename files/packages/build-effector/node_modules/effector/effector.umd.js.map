{"version":3,"file":"effector.umd.js","sources":["../../src/effector/naming.js","../../src/effector/createNode.js","../../src/effector/createUnit.js","../../src/effector/combine.js","../../src/effector/createEffect.js","../../src/effector/defer.js","../../src/effector/sample.js","../../src/effector/restore.js","../../src/effector/validate.js","../../src/effector/kind.js","../../src/effector/throw.js","../../src/effector/is.js","../../src/effector/getter.js","../../node_modules/symbol-observable/es/index.js","../../node_modules/symbol-observable/es/ponyfill.js","../../src/effector/id.js","../../src/effector/bind.js","../../src/effector/step.js","../../src/effector/stateRef.js","../../src/effector/caller.js","../../src/effector/own.js","../../src/effector/kernel.js","../../src/effector/clearNode.js","../../src/effector/subscription.js","../../src/effector/region.js","../../src/effector/forward.js","../../src/effector/watch.js","../../src/effector/forIn.js","../../src/effector/createDomain.js","../../src/effector/blocks.js","../../src/effector/attach.js","../../src/effector/createApi.js","../../src/effector/fromObservable.js","../../src/effector/guard.js","../../src/effector/merge.js","../../src/effector/split.js"],"sourcesContent":["//@flow\n\nimport {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //$todo\n  for (const key in objOrArr) {\n    //$todo\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //$todo\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string,\n  fullName: string,\n  path: string[],\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","//@flow\n\nimport {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...list[i])\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = ({hasRef, type, data}, reg) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === 'store') {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>,\n  from?: Graphite | Graphite[],\n  source?: Graphite | Graphite[],\n  parent?: Graphite | Graphite[],\n  to?: Graphite | Graphite[],\n  target?: Graphite | Graphite[],\n  child?: Graphite | Graphite[],\n  scope?: {[name: string]: any},\n  meta?: {[name: string]: any},\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain',\n    links?: Graphite | Graphite[],\n    owners?: Graphite | Graphite[]\n  }\n}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || 'crosslink',\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\n\nimport {is, isObject, isFunction, assertObject} from './is'\nimport {Store, Event, Effect} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, getCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {addToRegion, readTemplate} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {throwError} from './throw'\n\nconst normalizeConfig = (part, config) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentEventHook = (source, target) => {\n  if (getParent(source)) getParent(source).hooks.event(target)\n}\n\nlet isStrict\nexport const initUnit = (kind, unit, rawConfigA, rawConfigB) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const id = nextUnitID()\n  const {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (kind === 'domain' ? '' : id)\n  const compositeName = createName(name, parent)\n  unit.kind = kind\n  unit.id = id\n  unit.sid = sid\n  unit.shortName = name\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = fn => fn(unit)\n  unit.getType = () => compositeName.fullName\n  isStrict = strict\n  return {unit: kind, name, sid, named}\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from, to, op, fn) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event, op, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nexport function createEvent<Payload>(\n  nameOrConfig: any,\n  maybeConfig: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) =>\n    event.create(payload, args, args)\n  event.graphite = createNode({\n    meta: initUnit('event', event, maybeConfig, nameOrConfig),\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (payload, _, args) => {\n    launch(event, payload)\n    return payload\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: Function) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, 'map', fn)\n    return mapped\n  }\n  event.filter = fn => {\n    if (isFunction(fn)) {\n      console.error('.filter(fn) is deprecated, use .filterMap instead')\n      return filterMapEvent(event, fn)\n    }\n    return createEventFiltration(event, 'filter', fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  }\n  event.filterMap = bind(filterMapEvent, event)\n  event.prepend = fn => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentEventHook(event, contramapped)\n    return contramapped\n  }\n  addObservableApi(event, event)\n  const template = readTemplate()\n  if (template) {\n    getGraph(event).meta.nativeTemplate = template\n  }\n  return addToRegion(event)\n}\n\nexport function filterMapEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn?: (val: any) => any,\n): any {\n  return createEventFiltration(event, 'filterMap', fn, [\n    step.compute({fn: callStack}),\n    step.check.defined(),\n  ])\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState)\n  }\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      const currentPage = getCurrentPage()\n      if (!currentPage) return readRef(plainState)\n      if (currentPage.reg[plainState.id])\n        return readRef(currentPage.reg[plainState.id])\n      return readRef(plainState)\n    },\n    setState(state) {\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(events, fn) {\n      if (Array.isArray(events)) {\n        for (const event of events) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(events, fn)\n      }\n      return store\n    },\n    off(unit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, 'map', false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: 'map',\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!template.plain.includes(plainState)) {\n          if (!linkNode.seq.includes(template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    [$$observable]: () => addObservableApi(store, {}),\n  }\n  function onEvent(event, fn) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(updateStore(event, store, 'on', true, fn)),\n    )\n  }\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.update({\n        store: plainState,\n      }),\n      step.check.changed({\n        store: oldState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta: initUnit('store', store, props),\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  if (template) {\n    getGraph(store).meta.nativeTemplate = template\n  }\n  store.watch = store.subscribe = (\n    eventOrFn: Event<any> | Function,\n    fn?: Function,\n  ) => {\n    if (!fn || !is.unit(eventOrFn)) {\n      if (!isFunction(eventOrFn)) throwError('watch requires function handler')\n      const template = readTemplate()\n      if (template) {\n        template.watch.push({\n          of: plainState,\n          fn: eventOrFn,\n        })\n      } else {\n        eventOrFn(store.getState())\n      }\n      return watchUnit(store, eventOrFn)\n    }\n    if (!isFunction(fn)) throwError('second argument should be a function')\n    return eventOrFn.watch(payload => fn(store.getState(), payload))\n  }\n  own(store, [updates])\n  return addToRegion(store)\n}\n\nconst addObservableApi = (unit, target) => {\n  target.subscribe = (observer: Subscriber<any>) => {\n    assertObject(observer)\n    return unit.watch(upd => {\n      if (observer.next) {\n        observer.next(upd)\n      }\n    })\n  }\n  target[$$observable] = () => target\n  return target\n}\n\nconst updateStore = (\n  from,\n  store: Store<any>,\n  op,\n  stateFirst: boolean,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: 'a'}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!template.plain.includes(ref)) {\n        //if (!node.includes(template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!template.closure.includes(ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!node.includes(template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {getStoreState, getConfig, getNestedConfig} from './getter'\nimport {is, isFunction} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './forIn'\n\nexport function combine(...args: any[]): Store<any> {\n  if (args.length === 0) throwError('at least one argument required')\n  let handler\n  let stores\n  let config\n  if (getNestedConfig(args[0])) {\n    config = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = fn => list => fn(...list)\n\nconst storeCombination = (\n  isArray,\n  obj: any,\n  config?: string,\n  fn?: Function,\n) => {\n  const clone = isArray ? list => list.slice() : obj => Object.assign({}, obj)\n  const defaultState = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: 'a',\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: 'a',\n      target: rawShape,\n    }),\n    step.mov({\n      from: 'value',\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: 'barrier'}),\n    step.mov({\n      from: 'value',\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before = (rawShape.before = [])\n  forIn(obj, (child, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!template.plain.includes(childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n        type: 'map',\n        to: getStoreState(store),\n        fn,\n      }\n      : {\n        type: 'copy',\n        to: getStoreState(store),\n      },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","//@flow\n\nimport {Effect} from './unit.h'\nimport {step} from './typedef'\nimport {getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {\n  createNamedEvent,\n  createStore,\n  createEvent,\n  filterMapEvent,\n} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (value => {\n      console.error(`no handler used in ${instance.getType()}`)\n      return Promise.resolve()\n    })\n\n  getGraph(instance).meta.onCopy = ['runner']\n  getGraph(instance).meta.unit = instance.kind = 'effect'\n  instance.use = fn => {\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = filterMapEvent(anyway, {\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = filterMapEvent(anyway, {\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: (instance.use.getCurrent = () => handler),\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, {page}) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  getGraph(instance).scope.runner = effectRunner\n  getGraph(instance).seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    launch(instance, {params, req})\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({params, req, ok, anyway, page}) => data =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n          status: 'done',\n          params,\n          result: data,\n        }\n        : {\n          status: 'fail',\n          params,\n          error: data,\n        },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page,\n  })\n\nconst sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","//@flow\n\nexport function createDefer(): {\n  rs: (value: any) => any,\n  rj: (value: any) => any,\n  req: Promise<any>,\n  } {\n  const result = {}\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","//@flow\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {getStoreState, getConfig, getNestedConfig, getGraph} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {addToRegion, readTemplate} from './region'\nimport {throwError} from './throw'\n\nexport const shapeToStore = shape => (is.unit(shape) ? shape : combine(shape))\n\nexport function sample(...args): any {\n  let target\n  let name\n  let metadata\n  if (getNestedConfig(args[0])) {\n    metadata = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  let [source, clock, fn, greedy = false] = args\n\n  //config case\n  if (clock === undefined && 'source' in source) {\n    if ('clock' in source && source.clock == null)\n      throwError('config.clock should be defined')\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  name = metadata || name || source.shortName\n  source = shapeToStore(source)\n  clock = shapeToStore(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = null\n  }\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate = isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({\n            store: getStoreState(source),\n            to: fn ? 'a' : 'stack',\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'store'},\n      }),\n    ])\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    addToRegion(\n      createNode({\n        parent: source,\n        node: [\n          step.update({store: sourceState}),\n          step.mov({\n            from: 'value',\n            store: true,\n            target: hasSource,\n          }),\n        ],\n        family: {\n          owners: [source, target, clock],\n          links: target,\n        },\n        meta: {op: 'sample', sample: 'source'},\n      }),\n    )\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: 'a',\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","//@flow\nimport {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_, {result}) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result = {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n\nexport {\n  restore as restoreEvent,\n  restore as restoreEffect,\n  restore as restoreObject,\n}\n","//@flow\n\nimport {kind} from './index.h'\nimport {\n  store as storeKind,\n  event as eventKind,\n  effect as effectKind,\n  domain as domainKind,\n} from './kind'\n\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: mixed) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(storeKind)\nexport const event = is(eventKind)\nexport const effect = is(effectKind)\nexport const domain = is(domainKind)\n","//@flow\n\nimport {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const throwError = (message: string) => {\n  throw Error(message)\n}\n","//@flow\n\n//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect value to be an object') // or function\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\n\nexport const getGraph = (graph: Graphite): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = store => store.stateRef\nexport const getConfig = opts => opts.config\nexport const getNestedConfig = opts => opts.ɔ\nexport const getValue = stack => stack.value\nexport const getSubscribers = store => store.subscribers\nexport const getParent = unit => unit.parent\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","//@flow\n\nconst idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\n","//@flow\n\nexport const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","//@flow\nimport {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {\n  priority?: 'barrier' | 'sampler',\n}) => Barrier = ({priority = 'barrier'}) =>\n  cmd('barrier', false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b',\n  to?: 'stack' | 'a' | 'b',\n  store?: any,\n  target?: any,\n}) => Mov = ({\n  from = 'store',\n  store,\n  target,\n  to = target ? 'store' : 'stack',\n}) => cmd('mov', from === 'store', {from, store, to, target})\nexport const check: {\n  defined(): Check,\n  changed({store: StateRef}): Check,\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Filter = bind2(cmd, 'filter', false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {\n  store: StateRef,\n}) => Mov = ({store}) => mov({from: 'stack', target: store})\n","//@flow\n\nimport {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","//@flow\n\nexport const callStackAReg = (stack, {fn}, {a}) => fn(stack, a)\nexport const callARegStack = (stack, {fn}, {a}) => fn(a, stack)\nexport const callStack = (stack, {fn}) => fn(stack)\n","//@flow\n\nimport {Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nexport const own = (ownerUnit: Graphite, links: Graphite[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== 'domain') link.family.type = 'crosslink'\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\nimport {readRef} from './stateRef'\nimport {getGraph, getValue} from './getter'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Graph\n */\ntype Layer = {\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number,\n}\n\n/** Call stack */\ntype Stack = {\n  value: any,\n  a: any,\n  b: any,\n  parent: Stack | null,\n  node: Graph,\n  page: {[id: string]: any} | null,\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer,\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null,\n  /** right node */\n  r: QueueItem | null,\n}\ntype QueueBucket = {\n  first: QueueItem | null,\n  last: QueueItem | null,\n  size: number,\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean,\n  scope: {[key: string]: any},\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === 'sampler')\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap.v\n        heap = merge(heap.l, heap.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item.r\n      list.size -= 1\n      return item.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Graph,\n  parent: Stack | null,\n  value: any,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: 0,\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'barrier':\n      return 2\n    case 'sampler':\n      return 3\n    case 'effect':\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet alreadyStarted = false\nlet currentPage = null\nexport const getCurrentPage = () => currentPage\n\n/** main execution method */\nconst exec = () => {\n  const lastStartedState = {alreadyStarted, currentPage}\n  alreadyStarted = true\n  let stop\n  let skip\n  let graph\n  let value\n  let page\n  let reg\n  mem: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    graph = stack.node\n    currentPage = page = stack.page\n    reg = (page ? page : graph).reg\n    const local: Local = {\n      fail: false,\n      scope: graph.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < graph.seq.length && !stop; stepn++) {\n      const step = graph.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case 'barrier': {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue mem\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': value = stack.a; break\n            case 'b': value = stack.b; break\n            case 'value': value = data.store; break\n            case 'store':\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = null\n                reg = graph.reg\n                // }\n              }\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': stack.a = value; break\n            case 'b': stack.b = value; break\n            case 'store':\n              reg[data.target.id].current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip = getValue(stack) === readRef(reg[data.store.id])\n              break\n          }\n          break\n        case 'filter':\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== 'effect') {\n            pushHeap(stepn, stack, 'effect')\n            continue mem\n          }\n        case 'compute':\n          stack.value = tryRun(local, data, stack)\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < graph.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          graph.next[stepn],\n          stack,\n          getValue(stack),\n        )\n      }\n    }\n  }\n  alreadyStarted = lastStartedState.alreadyStarted\n  currentPage = lastStartedState.currentPage\n}\nexport const launch = (unit: Graphite, payload: any, upsert?: boolean) => {\n  let page = currentPage\n  let stack = null\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    page = 'page' in unit ? unit.page : page\n    if (unit.stack) stack = unit.stack\n    unit = unit.target\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem('pure', page, getGraph(unit[i]), stack, payload[i])\n    }\n  } else {\n    pushFirstHeapItem('pure', page, getGraph(unit), stack, payload)\n  }\n  if (upsert && alreadyStarted) return\n  exec()\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","//@flow\n\nimport {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\n\nconst removeItem = (list, item) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\nconst removeFromNode = (currentNode, targetNode) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //$off\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === 'crosslink'\n    ) {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === 'crosslink') {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean,\n  } = {},\n) => {\n  let isDomainUnit = false\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","//@flow\n\nimport {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","//@flow\nimport {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\n\nexport const addToRegion = unit => {\n  if (regionStack) own(getValue(regionStack), [unit])\n  return unit\n}\n\nlet regionStack = null\n\nexport const readTemplate = () => regionStack && regionStack.template\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template:\n      getGraph(unit).meta.template || (regionStack && regionStack.template),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n","//@flow\nimport {getConfig, getNestedConfig} from './getter'\nimport {createNode} from './createNode'\nimport {Subscription, Graphite, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {addToRegion} from './region'\n\nexport const createLinkNode = (\n  parent: Graphite,\n  child: Graphite,\n  {\n    node,\n    scope,\n    meta\n  }: {\n    node?: Array<Cmd | false | void | null>,\n    scope?: {[name: string]: any},\n    meta?: {[name: string]: any}\n  }\n) =>\n  addToRegion(\n    createNode({\n      node,\n      parent,\n      child,\n      scope,\n      meta,\n      family: {\n        owners: [parent, child],\n        links: child,\n      },\n    }),\n  )\nexport const forward = (opts: {\n  from: Graphite | Graphite[],\n  to: Graphite | Graphite[],\n  meta?: Object,\n}): Subscription => {\n  let config\n  if (getNestedConfig(opts)) {\n    config = getConfig(opts)\n    opts = getNestedConfig(opts)\n  }\n  const {from, to, meta = {op: 'forward'}} = opts\n  if (!from || !to) throwError('from and to fields should be defined')\n  if (config) meta.config = config\n  return createSubscription(\n    addToRegion(\n      createNode({\n        parent: from,\n        child: to,\n        meta,\n        family: {},\n      }),\n    ),\n  )\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription =>\n  createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n","//@flow\n\nexport const forIn = (obj, cb: (value: any, key: string) => void) => {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n","//@flow\n\nimport {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {addToRegion} from './region'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node) => {\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: 'domain'},\n  })\n\n  const result = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit('domain', result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  addToRegion(result)\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {readRef} from './stateRef'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== undefined &&\n    data !== readRef(state)\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n","//@flow\n\nimport {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentEventHook} from './createUnit'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\n\nexport function attach({source, effect, mapParams}) {\n  const attached = createEffect()\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req},\n    {finally: anyway, effect},\n    {a: states, page},\n  ) =>\n    launch({\n      target: effect,\n      params: {\n        params: mapParams(params, states),\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          }),\n          rj: onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          }),\n        },\n      },\n      page,\n      defer: true,\n    })\n\n  if (source) {\n    let state\n    if (is.store(source)) state = source\n    else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: 'store',\n      store: getStoreState(state),\n      to: 'a',\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  runner.scope.effect = effect\n  runner.meta.onCopy.push('effect')\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentEventHook(effect, attached)\n  return attached\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createEvent, applyParentEventHook} from './createUnit'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function createApi(\n  store: Store<any>,\n  setters: {[key: string]: Function},\n) {\n  const result = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {parent: getParent(store)}))\n    store.on(event, fn)\n    applyParentEventHook(store, event)\n  })\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    $$observable in observable ? observable[$$observable]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event: Event<T> = createEvent()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\n\nimport {getConfig, getNestedConfig} from './getter'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\n\nexport function guard(source, config) {\n  const meta = {op: 'guard'}\n  if (getNestedConfig(source)) {\n    meta.config = getConfig(source)\n    ;[source, config] = getNestedConfig(source)\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  const {filter, greedy, name = 'guard'} = config\n  const target = config.target || createEvent(name)\n  if (!is.unit(source)) source = combine(source)\n\n  if (is.unit(filter)) {\n    sample({\n      source: filter,\n      clock: source,\n      target: addToRegion(\n        createNode({\n          node: [\n            step.filter({\n              fn: ({guard}) => guard,\n            }),\n            step.compute({\n              fn: ({data}) => data,\n            }),\n          ],\n          child: target,\n          meta,\n          family: {\n            owners: [source, filter, target],\n            links: target,\n          },\n        }),\n      ),\n      fn: (guard, data) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","// @flow\n\nimport {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\n\nexport function merge<T>(\n  events: $ReadOnlyArray<Event<T> | Store<T> | Effect<T, any, any>>,\n): Event<T> {\n  const result = createEvent(unitObjectName(events, 'merge'))\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","//@flow\nimport {Event} from './unit.h'\nimport {is} from './is'\nimport {forIn} from './forIn'\n\nexport function split<S>(\n  unit: Event<S>,\n  cases: {[key: string]: (s: S) => boolean}\n): {[key: string]: Event<S>} {\n  const result = {}\n  let current: Event<S> = is.store(unit) ? unit.updates : unit\n  forIn(cases, (fn, key) => {\n    result[key] = current.filter({fn})\n    current = current.filter({\n      fn: data => !fn(data),\n    })\n  })\n  result.__ = current\n  return result\n}\n"],"names":["unitObjectName","objOrArr","method","name","comma","i","key","unit","is","compositeName","fullName","toString","createName","parent","path","composite","shortName","length","concat","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","sources","arrifyNodes","links","owners","seq","reg","item","push","addToReg","result","next","getOwners","getLinks","createEvent","nameOrConfig","maybeConfig","event","payload","args","create","graphite","initUnit","launch","watch","bind","watchUnit","map","fn","config","isObject","mapped","mapName","createComputation","filter","isFunction","console","error","filterMapEvent","createEventFiltration","step","callStack","filterMap","prepend","contramapped","getParent","template","readTemplate","getGraph","upward","applyParentEventHook","addObservableApi","nativeTemplate","addToRegion","defined","createStore","defaultState","props","onEvent","store","off","getSubscribers","set","createSubscription","updateStore","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","subscribers","Map","stateRef","getState","currentPage","getCurrentPage","readRef","id","setState","state","params","defer","reset","units","on","events","Array","isArray","currentSubscription","get","delete","firstState","lastResult","storeState","undefined","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","$$observable","changed","isStrict","throwError","subscribe","eventOrFn","of","own","combine","handler","stores","getNestedConfig","getConfig","structStoreShape","shapeReady","rawHandler","slice","obj","spreadArgs","storeCombination","createEffect","instance","defaultConfig","getType","Promise","resolve","onCopy","kind","use","anyway","finally","done","named","status","fail","doneData","failData","effectRunner","getHandler","getCurrent","req","page","onResolve","onSettled","ok","onReject","err","then","op","fx","runner","stack","rs","data","rj","upd","catch","createDefer","inFlight","x","pending","amount","sample","metadata","clock","greedy","shapeToStore","isUpward","targetTemplate","createLinkNode","priority","callARegStack","hasSource","sourceState","clockState","callStackAReg","restore","domain","ɔ","_","v","hooks","forIn","value","effect","message","Error","assertObject","graph","opts","getValue","joinName","tag","Symbol","self","window","global","module","Function","observable","ponyfill","idCount","nextUnitID","nextStepID","bind2","arg","cmd","hasRef","nextBarrierID","barrier","barrierID","mov","check","compute","run","update","current","a","ownerUnit","owner","link","list","heap","merge","b","ret","isSameType","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","pushHeap","idx","getPriority","bucket","t","barriers","Set","alreadyStarted","upsert","stop","skip","lastStartedState","mem","local","stepn","fullID","has","add","tryRun","exec","removeItem","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","regionStack","forward","normalizeConfig","part","loc","sid","rawConfigA","rawConfigB","thru","observer","stateFirst","storeRef","ref","closure","cb","clone","Object","assign","stateNew","rawShape","isFresh","childRef","field","defaultShape","sidechain","createHook","trigger","acc","hook","forEach","shape","n","mapParams","runnerSteps","attached","runnerFn","states","readStateRef","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","observableItem","disposer","complete","guard","rawName","currentComposite","cases","__"],"mappings":"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"}