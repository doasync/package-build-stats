{"version":3,"file":"fork.js","sources":["effector/defer.js","effector/fork.js","effector/getter.js","effector/bind.js","effector/id.js","effector/step.js","effector/caller.js","effector/createNode.js","effector/validate.js","effector/kind.js","effector/throw.js","effector/is.js","effector/clearNode.js","effector/watch.js","effector/subscription.js"],"sourcesContent":["//@flow\n\nexport function createDefer(): {\n  rs: (value: any) => any,\n  rj: (value: any) => any,\n  req: Promise<any>,\n  } {\n  const result = {}\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","//@flow\n\nimport {getGraph} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {isObject} from './is'\nimport {throwError} from './throw'\n\nimport {is, step, launch, createNode} from 'effector'\n\nconst stack = []\n\n/**\nhydrate state on client\n\nconst root = createDomain()\nhydrate(root, {\n  values: window.__initialState__\n})\n\n*/\nexport function hydrate(domain, {values}) {\n  if (!is.domain(domain)) {\n    throwError('first argument of hydrate should be domain')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  values = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  const units = flatGraph(domain)\n  for (const {meta, scope, reg} of units) {\n    if (meta.unit === 'store' && meta.sid && valuesSidList.includes(meta.sid)) {\n      reg[scope.state.id].current = values[meta.sid]\n    }\n  }\n  const nonComputedStores = [...domain.history.stores]\n  launch({\n    target: nonComputedStores,\n    params: nonComputedStores.map(store => store.getState()),\n  })\n}\n\n/**\nserialize state on server\n*/\nexport function serialize(\n  {clones},\n  {ignore = []}: {ignore?: Array<Store<any>>} = {},\n) {\n  const result = {}\n  for (const {meta, scope, reg} of clones) {\n    if (meta.unit !== 'store') continue\n    if (!meta.sid) continue\n    result[meta.sid] = reg[scope.state.id].current\n  }\n  for (const {sid} of ignore) {\n    if (sid) delete result[sid]\n  }\n  return result\n}\n\n/** invoke event in scope */\nexport function invoke(unit, payload) {\n  if (stack.length === 0) {\n    throwError('invoke cannot be called outside of forked .watch')\n  }\n  launch(stack[stack.length - 1](unit), payload)\n}\n\n/** bind event to scope */\nexport function scopeBind(unit) {\n  if (stack.length === 0) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const result = stack[stack.length - 1](unit)\n  return payload => {\n    launch(result, payload)\n  }\n}\nfunction universalLaunch(unit, payload) {\n  if (stack.length > 0) {\n    invoke(unit, payload)\n  } else {\n    launch(unit, payload)\n  }\n}\nfunction normalizeValues(values) {\n  if (values instanceof Map) {\n    const result = {}\n    for (const [key, value] of values) {\n      result[key.sid] = value\n    }\n    return result\n  }\n  return values\n}\nexport function fork(domain, {values = {}, deep = true} = {}) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  if (!domain.graphite.meta.withScopes) {\n    domain.graphite.meta.withScopes = true\n    domain.onCreateEvent(event => {\n      event.create = payload => {\n        universalLaunch(event, payload)\n        return payload\n      }\n    })\n    domain.onCreateEffect(effect => {\n      effect.create = params => {\n        const req = createDefer()\n        universalLaunch(effect, {params, req})\n        return req.req\n      }\n    })\n  }\n  values = normalizeValues(values)\n  return cloneGraph(domain, {values, deep})\n}\nexport function allSettled(\n  start,\n  {\n    scope: {\n      find,\n      graphite: {\n        scope: {forkInFlightCounter},\n      },\n    },\n    params: ctx,\n  },\n) {\n  const defer = createDefer()\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = find(start)\n  if (is.effect(start)) {\n    launch(contextStart, {\n      params: ctx,\n      req: {\n        rs() {},\n        rj() {},\n      },\n    })\n  } else {\n    launch(contextStart, ctx)\n  }\n  launch(forkInFlightCounter)\n  return defer.req\n}\nfunction flatGraph(unit) {\n  const list = []\n  ;(function traverse(node) {\n    if (list.includes(node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n/**\neverything we need to clone graph section\nreachable from given unit\n*/\nfunction cloneGraph(unit, {values, deep}) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: 'sampler'}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            defers.splice(0, defers.length).forEach(defer => {\n              defer.rs()\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: 'forkInFlightCounter'},\n  })\n\n  const clones = list.map(({seq, next, meta, scope, family}) => {\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: Object.assign({}, step.data),\n        hasRef: step.hasRef,\n      })),\n      child: [...next],\n      meta: Object.assign({}, meta),\n      scope: Object.assign({}, scope),\n    })\n    result.family = {\n      type: family.type,\n      links: [...family.links],\n      owners: [...family.owners],\n    }\n    return result\n  })\n\n  clones.forEach(node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    for (const id in reg) {\n      const ref = reg[id]\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      reg[id] = newRef\n    }\n    if (onCopy) {\n      for (let j = 0; j < onCopy.length; j++) {\n        scope[onCopy[j]] = findClone(scope[onCopy[j]])\n      }\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case 'store':\n        node.meta.wrapped = wrapStore(node)\n        break\n      case 'effect':\n        node.next.push(forkInFlightCounter)\n        break\n      case 'fx':\n        scope.finally.next.push(forkInFlightCounter)\n        break\n      case 'watch': {\n        const handler = scope.fn\n        scope.fn = data => {\n          stack.push(findClone)\n          try {\n            handler(data)\n          } finally {\n            stack.pop()\n          }\n        }\n        break\n      }\n    }\n  })\n\n  return {\n    clones,\n    find: findClone,\n    graphite: createNode({\n      family: {\n        type: 'domain',\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n  function findClone(unit) {\n    unit = getGraph(unit)\n    const index = list.indexOf(unit)\n    if (index === -1) throwError('not found')\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node) {\n  return {\n    kind: 'store',\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\nfunction forEachRelatedNode({next, family, meta}, cb) {\n  if (meta.unit === 'fork' || meta.unit === 'forkInFlightCounter') return\n  next.forEach(cb)\n  family.owners.forEach(cb)\n  family.links.forEach(cb)\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\n\nexport const getGraph = (graph: Graphite): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = store => store.stateRef\nexport const getConfig = opts => opts.config\nexport const getNestedConfig = opts => opts.É”\nexport const getValue = stack => stack.value\nexport const getSubscribers = store => store.subscribers\nexport const getParent = unit => unit.parent\n","//@flow\n\nexport const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","//@flow\n\nconst idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\n","//@flow\nimport {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {\n  priority?: 'barrier' | 'sampler',\n}) => Barrier = ({priority = 'barrier'}) =>\n  cmd('barrier', false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b',\n  to?: 'stack' | 'a' | 'b',\n  store?: any,\n  target?: any,\n}) => Mov = ({\n  from = 'store',\n  store,\n  target,\n  to = target ? 'store' : 'stack',\n}) => cmd('mov', from === 'store', {from, store, to, target})\nexport const check: {\n  defined(): Check,\n  changed({store: StateRef}): Check,\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Filter = bind2(cmd, 'filter', false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {\n  store: StateRef,\n}) => Mov = ({store}) => mov({from: 'stack', target: store})\n","//@flow\n\nexport const callStackAReg = (stack, {fn}, {a}) => fn(stack, a)\nexport const callARegStack = (stack, {fn}, {a}) => fn(a, stack)\nexport const callStack = (stack, {fn}) => fn(stack)\n","//@flow\n\nimport {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...list[i])\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = ({hasRef, type, data}, reg) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === 'store') {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>,\n  from?: Graphite | Graphite[],\n  source?: Graphite | Graphite[],\n  parent?: Graphite | Graphite[],\n  to?: Graphite | Graphite[],\n  target?: Graphite | Graphite[],\n  child?: Graphite | Graphite[],\n  scope?: {[name: string]: any},\n  meta?: {[name: string]: any},\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain',\n    links?: Graphite | Graphite[],\n    owners?: Graphite | Graphite[]\n  }\n}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || 'crosslink',\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","//@flow\n\nimport {kind} from './index.h'\nimport {\n  store as storeKind,\n  event as eventKind,\n  effect as effectKind,\n  domain as domainKind,\n} from './kind'\n\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: mixed) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(storeKind)\nexport const event = is(eventKind)\nexport const effect = is(effectKind)\nexport const domain = is(domainKind)\n","//@flow\n\nimport {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const throwError = (message: string) => {\n  throw Error(message)\n}\n","//@flow\n\n//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect value to be an object') // or function\n}\n","//@flow\n\nimport {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\n\nconst removeItem = (list, item) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\nconst removeFromNode = (currentNode, targetNode) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //$off\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === 'crosslink'\n    ) {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === 'crosslink') {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean,\n  } = {},\n) => {\n  let isDomainUnit = false\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription =>\n  createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n","//@flow\n\nimport {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n"],"names":["createDefer","result","req","Promise","rs","rj","catch","err","invoke","unit","payload","stack","length","throwError","launch","universalLaunch","normalizeValues","values","Map","key","value","sid","flatGraph","list","traverse","node","includes","push","forEachRelatedNode","getGraph","next","family","meta","cb","forEach","owners","links","graph","graphite","getOwners","getLinks","bind2","fn","target","arg","bind","nextStepID","id","toString","idCount","cmd","type","hasRef","data","run","callStack","arrifyNodes","Array","isArray","i","map","addToReg","reg","store","to","is","obj","isFunction","isObject","kind","domain","message","Error","removeItem","item","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","seq","scope","pop","sample","clearMap","clear","clearNode","ownerSet","delete","subscribers","history","events","effects","stores","domains","watchUnit","handler","undefined","unsubscribe","createSubscription","from","source","parent","child","familyRaw","sources","createNode","step","op","start","find","forkInFlightCounter","params","ctx","defer","defers","contextStart","effect","withScopes","onCreateEvent","event","create","onCreateEffect","findClone","index","clones","refs","inFlight","fxID","compute","_","named","barrier","priority","resolve","then","Object","assign","onCopy","ref","newRef","get","current","set","j","siblings","wrapped","getState","state","updates","watch","wrapStore","finally","cloneGraph","valuesSidList","getOwnPropertyNames","units","nonComputedStores","ignore"],"mappings":"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"}