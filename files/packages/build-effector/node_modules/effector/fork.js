function e(){let e={};return e.req=new Promise((t,r)=>{e.rs=t,e.rj=r}),e.req.catch(()=>{}),e}function t(e,t){0===O.length&&b('invoke cannot be called outside of forked .watch'),effector.launch(O[O.length-1](e),t)}function r(e,r){O.length>0?t(e,r):effector.launch(e,r)}function n(e){if(e instanceof Map){let t={};for(let[r,n]of e)t[r.sid]=n;return t}return e}function o(e){let t=[];return function e(r){t.includes(r)||(t.push(r),s(r,e))}(a(e)),t}function s({next:e,family:t,meta:r},n){'fork'!==r.unit&&'forkInFlightCounter'!==r.unit&&(e.forEach(n),t.owners.forEach(n),t.links.forEach(n))}Object.defineProperty(exports,'__esModule',{value:1});var effector=require('effector');let a=e=>e.graphite||e,l=e=>e.family.owners,i=e=>e.family.links,f=(e,t,r)=>e.bind(null,t,r),c=(()=>{let e=0;return()=>(++e).toString(36)})();const p=(e,t,r)=>({id:c(),type:e,data:r,hasRef:t});f(p,'compute',0),f(p,'filter',0);let u=f(p,'run',0),d=(e,{fn:t})=>t(e);const h=(e=[])=>{let t=[];if(Array.isArray(e))for(let r=0;r<e.length;r++)Array.isArray(e[r])?t.push(...e[r]):t.push(e[r]);else t.push(e);return t.map(a)};let m=({hasRef:e,type:t,data:r},n)=>{let o;e&&(o=r.store,n[o.id]=o),'mov'===t&&'store'===r.to&&(o=r.target,n[o.id]=o)};const g=e=>t=>(e=>(w(e)||x(e))&&'kind'in e)(t)&&t.kind===e;let y=g('store'),k=g('domain'),b=e=>{throw Error(e)},x=e=>'object'==typeof e&&null!==e,w=e=>'function'==typeof e;const v=(e,t)=>{let r=e.indexOf(t);-1!==r&&e.splice(r,1)},q=(e,t)=>{v(e.next,t),v(l(e),t),v(i(e),t)},j=(e,t,r)=>{let n;e.next.length=0,e.seq.length=0,e.scope=null;let o=i(e);for(;n=o.pop();)q(n,e),(t||r&&!e.meta.sample||'crosslink'===n.family.type)&&j(n,t,r);for(o=l(e);n=o.pop();)q(n,e),r&&'crosslink'===n.family.type&&j(n,t,r)},I=e=>e.clear();let E=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),y(e))I(e.subscribers);else if(k(e)){r=1;let t=e.history;I(t.events),I(t.effects),I(t.stores),I(t.domains)}j(a(e),!!t,r)},F=(e,t)=>(e=>{let t=f(E,e,void 0);return t.unsubscribe=t,t})((({node:e=[],from:t,source:r,parent:n=t||r,to:o,target:s,child:a=o||s,scope:f={},meta:c={},family:p={type:'regular'}})=>{let u=h(n),d=h(p.links),g=h(p.owners),y=[],k={};for(let t=0;t<e.length;t++){let r=e[t];r&&(y.push(r),m(r,k))}let b={seq:y,next:h(a),meta:c,scope:f,family:{type:p.type||'crosslink',links:d,owners:g},reg:k};for(let e=0;e<d.length;e++)l(d[e]).push(b);for(let e=0;e<g.length;e++)i(g[e]).push(b);for(let e=0;e<u.length;e++)u[e].next.push(b);return b})({scope:{fn:t},node:[u({fn:d})],parent:e,meta:{op:'watch'},family:{owners:e}}));const O=[];exports.allSettled=(t,{scope:{find:r,graphite:{scope:{forkInFlightCounter:n}}},params:o})=>{let s=e();n.scope.defers.push(s);let a=r(t);return effector.is.effect(t)?effector.launch(a,{params:o,req:{rs(){},rj(){}}}):effector.launch(a,o),effector.launch(n),s.req},exports.fork=(t,{values:l={},deep:i=1}={})=>(effector.is.domain(t)||b('first argument of fork should be domain'),t.graphite.meta.withScopes||(t.graphite.meta.withScopes=1,t.onCreateEvent(e=>{e.create=t=>(r(e,t),t)}),t.onCreateEffect(t=>{t.create=n=>{let o=e();return r(t,{params:n,req:o}),o.req}})),((e,{values:t})=>{function r(e){e=a(e);let t=n.indexOf(e);return-1===t&&b('not found'),f[t]}let n=o(e),l=new Map,i=effector.createNode({scope:{defers:[],inFlight:0,fxID:0},node:[effector.step.compute({fn(e,t,r){r.parent?'finally'===r.parent.node.meta.named?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1}}),effector.step.barrier({priority:'sampler'}),effector.step.run({fn(e,t){let{inFlight:r,defers:n,fxID:o}=t;r>0||0===n.length||Promise.resolve().then(()=>{t.fxID===o&&n.splice(0,n.length).forEach(e=>{e.rs()})})}})],meta:{unit:'forkInFlightCounter'}}),f=n.map(({seq:e,next:t,meta:r,scope:n,family:o})=>{let s=effector.createNode({node:e.map(e=>({id:e.id,type:e.type,data:Object.assign({},e.data),hasRef:e.hasRef})),child:[...t],meta:Object.assign({},r),scope:Object.assign({},n)});return s.family={type:o.type,links:[...o.links],owners:[...o.owners]},s});return f.forEach(e=>{let{reg:n,scope:o,meta:{onCopy:a,op:f,unit:c}}=e;for(let e in n){let r=n[e],o=l.get(r);o||(o={id:r.id,current:r.id in t?t[r.id]:r.current},l.set(r,o)),n[e]=o}if(a)for(let e=0;e<a.length;e++)o[a[e]]=r(o[a[e]]);switch(s(e,(e,t,n)=>{n[t]=r(e)}),f||c){case'store':e.meta.wrapped=(e=>{return{kind:'store',getState:()=>e.reg[e.scope.state.id].current,updates:{watch:(t=F,r=e,t.bind(null,r))},graphite:e,family:e.family};var t,r})(e);break;case'effect':e.next.push(i);break;case'fx':o.finally.next.push(i);break;case'watch':{let e=o.fn;o.fn=t=>{O.push(r);try{e(t)}finally{O.pop()}};break}}}),{clones:f,find:r,graphite:effector.createNode({family:{type:'domain',links:[i,...f]},meta:{unit:'fork'},scope:{forkInFlightCounter:i}})}})(t,{values:l=n(l),deep:i})),exports.hydrate=(e,{values:t})=>{effector.is.domain(e)||b('first argument of hydrate should be domain'),x(t)||b('values property should be an object'),t=n(t);let r=Object.getOwnPropertyNames(t),s=o(e);for(let{meta:e,scope:n,reg:o}of s)'store'===e.unit&&e.sid&&r.includes(e.sid)&&(o[n.state.id].current=t[e.sid]);let a=[...e.history.stores];effector.launch({target:a,params:a.map(e=>e.getState())})},exports.invoke=t,exports.scopeBind=e=>{0===O.length&&b('scopeBind cannot be called outside of forked .watch');let t=O[O.length-1](e);return e=>{effector.launch(t,e)}},exports.serialize=({clones:e},{ignore:t=[]}={})=>{let r={};for(let{meta:t,scope:n,reg:o}of e)'store'===t.unit&&t.sid&&(r[t.sid]=o[n.state.id].current);for(let{sid:e}of t)e&&delete r[e];return r};
//# sourceMappingURL=fork.js.map
