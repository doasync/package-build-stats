{"version":3,"file":"effector.es.js","sources":["effector/naming.js","effector/createNode.js","effector/region.js","effector/createUnit.js","effector/combine.js","effector/createEffect.js","effector/defer.js","effector/attach.js","effector/createApi.js","effector/createDomain.js","effector/fromObservable.js","effector/sample.js","effector/guard.js","effector/merge.js","effector/restore.js","effector/split.js","effector/kind.js","effector/validate.js","effector/throw.js","effector/is.js","effector/getter.js","effector/id.js","effector/bind.js","effector/step.js","effector/stateRef.js","effector/caller.js","effector/own.js","effector/kernel.js","effector/clearNode.js","effector/subscription.js","effector/forward.js","effector/watch.js","effector/forIn.js","effector/blocks.js"],"sourcesContent":["//@flow\n\nimport {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //$todo\n  for (const key in objOrArr) {\n    //$todo\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //$todo\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string,\n  fullName: string,\n  path: string[],\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","//@flow\n\nimport {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...list[i])\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = ({hasRef, type, data}, reg) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === 'store') {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>,\n  from?: Graphite | Graphite[],\n  source?: Graphite | Graphite[],\n  parent?: Graphite | Graphite[],\n  to?: Graphite | Graphite[],\n  target?: Graphite | Graphite[],\n  child?: Graphite | Graphite[],\n  scope?: {[name: string]: any},\n  meta?: {[name: string]: any},\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain',\n    links?: Graphite | Graphite[],\n    owners?: Graphite | Graphite[]\n  }\n}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || 'crosslink',\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","//@flow\nimport {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\n\nexport const addToRegion = unit => {\n  if (regionStack) own(getValue(regionStack), [unit])\n  return unit\n}\n\nlet regionStack = null\n\nexport const readTemplate = () => regionStack && regionStack.template\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template:\n      getGraph(unit).meta.template || (regionStack && regionStack.template),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\n\nimport {is, isObject, isFunction, assertObject} from './is'\nimport {Store, Event, Effect} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, getCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {addToRegion, readTemplate} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {throwError} from './throw'\n\nconst normalizeConfig = (part, config) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentEventHook = (source, target) => {\n  if (getParent(source)) getParent(source).hooks.event(target)\n}\n\nlet isStrict\nexport const initUnit = (kind, unit, rawConfigA, rawConfigB) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const id = nextUnitID()\n  const {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (kind === 'domain' ? '' : id)\n  const compositeName = createName(name, parent)\n  unit.kind = kind\n  unit.id = id\n  unit.sid = sid\n  unit.shortName = name\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = fn => fn(unit)\n  unit.getType = () => compositeName.fullName\n  isStrict = strict\n  return {unit: kind, name, sid, named}\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from, to, op, fn) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event, op, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nexport function createEvent<Payload>(\n  nameOrConfig: any,\n  maybeConfig: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) =>\n    event.create(payload, args, args)\n  event.graphite = createNode({\n    meta: initUnit('event', event, maybeConfig, nameOrConfig),\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (payload, _, args) => {\n    launch(event, payload)\n    return payload\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: Function) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, 'map', fn)\n    return mapped\n  }\n  event.filter = fn => {\n    if (isFunction(fn)) {\n      console.error('.filter(fn) is deprecated, use .filterMap instead')\n      return filterMapEvent(event, fn)\n    }\n    return createEventFiltration(event, 'filter', fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  }\n  event.filterMap = bind(filterMapEvent, event)\n  event.prepend = fn => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentEventHook(event, contramapped)\n    return contramapped\n  }\n  addObservableApi(event, event)\n  const template = readTemplate()\n  if (template) {\n    getGraph(event).meta.nativeTemplate = template\n  }\n  return addToRegion(event)\n}\n\nexport function filterMapEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn?: (val: any) => any,\n): any {\n  return createEventFiltration(event, 'filterMap', fn, [\n    step.compute({fn: callStack}),\n    step.check.defined(),\n  ])\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState)\n  }\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      const currentPage = getCurrentPage()\n      if (!currentPage) return readRef(plainState)\n      if (currentPage.reg[plainState.id])\n        return readRef(currentPage.reg[plainState.id])\n      return readRef(plainState)\n    },\n    setState(state) {\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(events, fn) {\n      if (Array.isArray(events)) {\n        for (const event of events) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(events, fn)\n      }\n      return store\n    },\n    off(unit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, 'map', false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: 'map',\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!template.plain.includes(plainState)) {\n          if (!linkNode.seq.includes(template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    [$$observable]: () => addObservableApi(store, {}),\n  }\n  function onEvent(event, fn) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(updateStore(event, store, 'on', true, fn)),\n    )\n  }\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.update({\n        store: plainState,\n      }),\n      step.check.changed({\n        store: oldState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta: initUnit('store', store, props),\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  if (template) {\n    getGraph(store).meta.nativeTemplate = template\n  }\n  store.watch = store.subscribe = (\n    eventOrFn: Event<any> | Function,\n    fn?: Function,\n  ) => {\n    if (!fn || !is.unit(eventOrFn)) {\n      if (!isFunction(eventOrFn)) throwError('watch requires function handler')\n      const template = readTemplate()\n      if (template) {\n        template.watch.push({\n          of: plainState,\n          fn: eventOrFn,\n        })\n      } else {\n        eventOrFn(store.getState())\n      }\n      return watchUnit(store, eventOrFn)\n    }\n    if (!isFunction(fn)) throwError('second argument should be a function')\n    return eventOrFn.watch(payload => fn(store.getState(), payload))\n  }\n  own(store, [updates])\n  return addToRegion(store)\n}\n\nconst addObservableApi = (unit, target) => {\n  target.subscribe = (observer: Subscriber<any>) => {\n    assertObject(observer)\n    return unit.watch(upd => {\n      if (observer.next) {\n        observer.next(upd)\n      }\n    })\n  }\n  target[$$observable] = () => target\n  return target\n}\n\nconst updateStore = (\n  from,\n  store: Store<any>,\n  op,\n  stateFirst: boolean,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: 'a'}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!template.plain.includes(ref)) {\n        //if (!node.includes(template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!template.closure.includes(ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!node.includes(template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {getStoreState, getConfig, getNestedConfig} from './getter'\nimport {is, isFunction} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './forIn'\n\nexport function combine(...args: any[]): Store<any> {\n  if (args.length === 0) throwError('at least one argument required')\n  let handler\n  let stores\n  let config\n  if (getNestedConfig(args[0])) {\n    config = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = fn => list => fn(...list)\n\nconst storeCombination = (\n  isArray,\n  obj: any,\n  config?: string,\n  fn?: Function,\n) => {\n  const clone = isArray ? list => list.slice() : obj => Object.assign({}, obj)\n  const defaultState = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: 'a',\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: 'a',\n      target: rawShape,\n    }),\n    step.mov({\n      from: 'value',\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: 'barrier'}),\n    step.mov({\n      from: 'value',\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before = (rawShape.before = [])\n  forIn(obj, (child, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!template.plain.includes(childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n        type: 'map',\n        to: getStoreState(store),\n        fn,\n      }\n      : {\n        type: 'copy',\n        to: getStoreState(store),\n      },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","//@flow\n\nimport {Effect} from './unit.h'\nimport {step} from './typedef'\nimport {getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {\n  createNamedEvent,\n  createStore,\n  createEvent,\n  filterMapEvent,\n} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (value => {\n      console.error(`no handler used in ${instance.getType()}`)\n      return Promise.resolve()\n    })\n\n  getGraph(instance).meta.onCopy = ['runner']\n  getGraph(instance).meta.unit = instance.kind = 'effect'\n  instance.use = fn => {\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = filterMapEvent(anyway, {\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = filterMapEvent(anyway, {\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: (instance.use.getCurrent = () => handler),\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, {page}) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  getGraph(instance).scope.runner = effectRunner\n  getGraph(instance).seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    launch(instance, {params, req})\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({params, req, ok, anyway, page}) => data =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n          status: 'done',\n          params,\n          result: data,\n        }\n        : {\n          status: 'fail',\n          params,\n          error: data,\n        },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page,\n  })\n\nconst sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","//@flow\n\nexport function createDefer(): {\n  rs: (value: any) => any,\n  rj: (value: any) => any,\n  req: Promise<any>,\n  } {\n  const result = {}\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","//@flow\n\nimport {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentEventHook} from './createUnit'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\n\nexport function attach({source, effect, mapParams}) {\n  const attached = createEffect()\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req},\n    {finally: anyway, effect},\n    {a: states, page},\n  ) =>\n    launch({\n      target: effect,\n      params: {\n        params: mapParams(params, states),\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          }),\n          rj: onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          }),\n        },\n      },\n      page,\n      defer: true,\n    })\n\n  if (source) {\n    let state\n    if (is.store(source)) state = source\n    else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: 'store',\n      store: getStoreState(state),\n      to: 'a',\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  runner.scope.effect = effect\n  runner.meta.onCopy.push('effect')\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentEventHook(effect, attached)\n  return attached\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createEvent, applyParentEventHook} from './createUnit'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function createApi(\n  store: Store<any>,\n  setters: {[key: string]: Function},\n) {\n  const result = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {parent: getParent(store)}))\n    store.on(event, fn)\n    applyParentEventHook(store, event)\n  })\n  return result\n}\n","//@flow\n\nimport {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {addToRegion} from './region'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node) => {\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: 'domain'},\n  })\n\n  const result = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit('domain', result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  addToRegion(result)\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    $$observable in observable ? observable[$$observable]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event: Event<T> = createEvent()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {getStoreState, getConfig, getNestedConfig, getGraph} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {addToRegion, readTemplate} from './region'\nimport {throwError} from './throw'\n\nexport const shapeToStore = shape => (is.unit(shape) ? shape : combine(shape))\n\nexport function sample(...args): any {\n  let target\n  let name\n  let metadata\n  if (getNestedConfig(args[0])) {\n    metadata = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  let [source, clock, fn, greedy = false] = args\n\n  //config case\n  if (clock === undefined && 'source' in source) {\n    if ('clock' in source && source.clock == null)\n      throwError('config.clock should be defined')\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  name = metadata || name || source.shortName\n  source = shapeToStore(source)\n  clock = shapeToStore(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = null\n  }\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate = isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({\n            store: getStoreState(source),\n            to: fn ? 'a' : 'stack',\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'store'},\n      }),\n    ])\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    addToRegion(\n      createNode({\n        parent: source,\n        node: [\n          step.update({store: sourceState}),\n          step.mov({\n            from: 'value',\n            store: true,\n            target: hasSource,\n          }),\n        ],\n        family: {\n          owners: [source, target, clock],\n          links: target,\n        },\n        meta: {op: 'sample', sample: 'source'},\n      }),\n    )\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: 'a',\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","//@flow\n\nimport {getConfig, getNestedConfig} from './getter'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\n\nexport function guard(source, config) {\n  const meta = {op: 'guard'}\n  if (getNestedConfig(source)) {\n    meta.config = getConfig(source)\n    ;[source, config] = getNestedConfig(source)\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  const {filter, greedy, name = 'guard'} = config\n  const target = config.target || createEvent(name)\n  if (!is.unit(source)) source = combine(source)\n\n  if (is.unit(filter)) {\n    sample({\n      source: filter,\n      clock: source,\n      target: addToRegion(\n        createNode({\n          node: [\n            step.filter({\n              fn: ({guard}) => guard,\n            }),\n            step.compute({\n              fn: ({data}) => data,\n            }),\n          ],\n          child: target,\n          meta,\n          family: {\n            owners: [source, filter, target],\n            links: target,\n          },\n        }),\n      ),\n      fn: (guard, data) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","// @flow\n\nimport {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\n\nexport function merge<T>(\n  events: $ReadOnlyArray<Event<T> | Store<T> | Effect<T, any, any>>,\n): Event<T> {\n  const result = createEvent(unitObjectName(events, 'merge'))\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","//@flow\nimport {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_, {result}) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result = {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n\nexport {\n  restore as restoreEvent,\n  restore as restoreEffect,\n  restore as restoreObject,\n}\n","//@flow\nimport {Event} from './unit.h'\nimport {is} from './is'\nimport {forIn} from './forIn'\n\nexport function split<S>(\n  unit: Event<S>,\n  cases: {[key: string]: (s: S) => boolean}\n): {[key: string]: Event<S>} {\n  const result = {}\n  let current: Event<S> = is.store(unit) ? unit.updates : unit\n  forIn(cases, (fn, key) => {\n    result[key] = current.filter({fn})\n    current = current.filter({\n      fn: data => !fn(data),\n    })\n  })\n  result.__ = current\n  return result\n}\n","//@flow\n\nimport {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nimport {kind} from './index.h'\nimport {\n  store as storeKind,\n  event as eventKind,\n  effect as effectKind,\n  domain as domainKind,\n} from './kind'\n\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: mixed) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(storeKind)\nexport const event = is(eventKind)\nexport const effect = is(effectKind)\nexport const domain = is(domainKind)\n","//@flow\n\nexport const throwError = (message: string) => {\n  throw Error(message)\n}\n","//@flow\n\n//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect value to be an object') // or function\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\n\nexport const getGraph = (graph: Graphite): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = store => store.stateRef\nexport const getConfig = opts => opts.config\nexport const getNestedConfig = opts => opts.ɔ\nexport const getValue = stack => stack.value\nexport const getSubscribers = store => store.subscribers\nexport const getParent = unit => unit.parent\n","//@flow\n\nconst idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\n","//@flow\n\nexport const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","//@flow\nimport {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {\n  priority?: 'barrier' | 'sampler',\n}) => Barrier = ({priority = 'barrier'}) =>\n  cmd('barrier', false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b',\n  to?: 'stack' | 'a' | 'b',\n  store?: any,\n  target?: any,\n}) => Mov = ({\n  from = 'store',\n  store,\n  target,\n  to = target ? 'store' : 'stack',\n}) => cmd('mov', from === 'store', {from, store, to, target})\nexport const check: {\n  defined(): Check,\n  changed({store: StateRef}): Check,\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Filter = bind2(cmd, 'filter', false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {\n  store: StateRef,\n}) => Mov = ({store}) => mov({from: 'stack', target: store})\n","//@flow\n\nimport {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","//@flow\n\nexport const callStackAReg = (stack, {fn}, {a}) => fn(stack, a)\nexport const callARegStack = (stack, {fn}, {a}) => fn(a, stack)\nexport const callStack = (stack, {fn}) => fn(stack)\n","//@flow\n\nimport {Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nexport const own = (ownerUnit: Graphite, links: Graphite[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== 'domain') link.family.type = 'crosslink'\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\nimport {readRef} from './stateRef'\nimport {getGraph, getValue} from './getter'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Graph\n */\ntype Layer = {\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number,\n}\n\n/** Call stack */\ntype Stack = {\n  value: any,\n  a: any,\n  b: any,\n  parent: Stack | null,\n  node: Graph,\n  page: {[id: string]: any} | null,\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer,\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null,\n  /** right node */\n  r: QueueItem | null,\n}\ntype QueueBucket = {\n  first: QueueItem | null,\n  last: QueueItem | null,\n  size: number,\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean,\n  scope: {[key: string]: any},\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === 'sampler')\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap.v\n        heap = merge(heap.l, heap.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item.r\n      list.size -= 1\n      return item.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Graph,\n  parent: Stack | null,\n  value: any,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: 0,\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'barrier':\n      return 2\n    case 'sampler':\n      return 3\n    case 'effect':\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet alreadyStarted = false\nlet currentPage = null\nexport const getCurrentPage = () => currentPage\n\n/** main execution method */\nconst exec = () => {\n  const lastStartedState = {alreadyStarted, currentPage}\n  alreadyStarted = true\n  let stop\n  let skip\n  let graph\n  let value\n  let page\n  let reg\n  mem: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    graph = stack.node\n    currentPage = page = stack.page\n    reg = (page ? page : graph).reg\n    const local: Local = {\n      fail: false,\n      scope: graph.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < graph.seq.length && !stop; stepn++) {\n      const step = graph.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case 'barrier': {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue mem\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': value = stack.a; break\n            case 'b': value = stack.b; break\n            case 'value': value = data.store; break\n            case 'store':\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = null\n                reg = graph.reg\n                // }\n              }\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': stack.a = value; break\n            case 'b': stack.b = value; break\n            case 'store':\n              reg[data.target.id].current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip = getValue(stack) === readRef(reg[data.store.id])\n              break\n          }\n          break\n        case 'filter':\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== 'effect') {\n            pushHeap(stepn, stack, 'effect')\n            continue mem\n          }\n        case 'compute':\n          stack.value = tryRun(local, data, stack)\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < graph.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          graph.next[stepn],\n          stack,\n          getValue(stack),\n        )\n      }\n    }\n  }\n  alreadyStarted = lastStartedState.alreadyStarted\n  currentPage = lastStartedState.currentPage\n}\nexport const launch = (unit: Graphite, payload: any, upsert?: boolean) => {\n  let page = currentPage\n  let stack = null\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    page = 'page' in unit ? unit.page : page\n    if (unit.stack) stack = unit.stack\n    unit = unit.target\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem('pure', page, getGraph(unit[i]), stack, payload[i])\n    }\n  } else {\n    pushFirstHeapItem('pure', page, getGraph(unit), stack, payload)\n  }\n  if (upsert && alreadyStarted) return\n  exec()\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","//@flow\n\nimport {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\n\nconst removeItem = (list, item) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\nconst removeFromNode = (currentNode, targetNode) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //$off\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === 'crosslink'\n    ) {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === 'crosslink') {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean,\n  } = {},\n) => {\n  let isDomainUnit = false\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","//@flow\n\nimport {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","//@flow\nimport {getConfig, getNestedConfig} from './getter'\nimport {createNode} from './createNode'\nimport {Subscription, Graphite, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {addToRegion} from './region'\n\nexport const createLinkNode = (\n  parent: Graphite,\n  child: Graphite,\n  {\n    node,\n    scope,\n    meta\n  }: {\n    node?: Array<Cmd | false | void | null>,\n    scope?: {[name: string]: any},\n    meta?: {[name: string]: any}\n  }\n) =>\n  addToRegion(\n    createNode({\n      node,\n      parent,\n      child,\n      scope,\n      meta,\n      family: {\n        owners: [parent, child],\n        links: child,\n      },\n    }),\n  )\nexport const forward = (opts: {\n  from: Graphite | Graphite[],\n  to: Graphite | Graphite[],\n  meta?: Object,\n}): Subscription => {\n  let config\n  if (getNestedConfig(opts)) {\n    config = getConfig(opts)\n    opts = getNestedConfig(opts)\n  }\n  const {from, to, meta = {op: 'forward'}} = opts\n  if (!from || !to) throwError('from and to fields should be defined')\n  if (config) meta.config = config\n  return createSubscription(\n    addToRegion(\n      createNode({\n        parent: from,\n        child: to,\n        meta,\n        family: {},\n      }),\n    ),\n  )\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription =>\n  createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n","//@flow\n\nexport const forIn = (obj, cb: (value: any, key: string) => void) => {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {readRef} from './stateRef'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== undefined &&\n    data !== readRef(state)\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n"],"names":["unitObjectName","objOrArr","method","name","comma","i","key","unit","is","compositeName","fullName","toString","setStoreName","store","rawName","createName","getParent","shortName","currentComposite","path","parent","composite","length","concat","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","sources","arrifyNodes","links","owners","seq","reg","item","push","addToReg","result","next","getOwners","getLinks","withRegion","cb","regionStack","value","template","getGraph","createEvent","nameOrConfig","maybeConfig","event","payload","args","create","graphite","initUnit","launch","watch","bind","watchUnit","map","fn","config","isObject","mapped","mapName","createComputation","filter","isFunction","console","error","filterMapEvent","createEventFiltration","step","callStack","filterMap","prepend","contramapped","readTemplate","upward","applyParentEventHook","addObservableApi","nativeTemplate","addToRegion","defined","createStore","defaultState","props","onEvent","off","getSubscribers","set","createSubscription","updateStore","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","subscribers","Map","stateRef","getState","currentPage","getCurrentPage","readRef","id","setState","state","params","defer","reset","units","on","events","Array","isArray","currentSubscription","get","delete","firstState","lastResult","storeState","undefined","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","$$observable","changed","isStrict","throwError","subscribe","eventOrFn","of","own","combine","handler","stores","getNestedConfig","getConfig","structStoreShape","shapeReady","rawHandler","slice","obj","spreadArgs","storeCombination","createEffect","instance","defaultConfig","getType","Promise","resolve","onCopy","kind","use","anyway","finally","done","named","status","fail","doneData","failData","effectRunner","getHandler","getCurrent","req","page","onResolve","onSettled","ok","onReject","err","then","op","fx","runner","stack","rs","data","rj","upd","catch","createDefer","inFlight","x","pending","amount","attach","effect","mapParams","runnerSteps","attached","runnerFn","a","states","readStateRef","_","splice","createApi","setters","forIn","createDomain","domains","Set","effects","history","domain","hooks","onCreateEvent","createHook","onCreateEffect","onCreateStore","onCreateDomain","forward","fromObservable","observable","assertObject","observableItem","disposer","bind2","clearNode","complete","sample","metadata","clock","greedy","shapeToStore","isUpward","targetTemplate","createLinkNode","priority","callARegStack","hasSource","sourceState","clockState","callStackAReg","guard","merge","restore","ɔ","v","split","cases","current","__","message","Error","graph","opts","getValue","joinName","tag","idCount","nextUnitID","nextStepID","arg","cmd","hasRef","nextBarrierID","barrier","barrierID","mov","check","compute","run","update","ownerUnit","owner","link","list","heap","b","ret","isSameType","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","pushHeap","idx","getPriority","bucket","t","barriers","alreadyStarted","upsert","stop","skip","lastStartedState","mem","local","stepn","fullID","has","add","tryRun","exec","removeItem","pos","indexOf","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","ownerSet","unsubscribe","normalizeConfig","part","loc","sid","rawConfigA","rawConfigB","thru","observer","stateFirst","storeRef","ref","closure","clone","Object","assign","stateNew","rawShape","isFresh","childRef","field","defaultShape","sidechain","trigger","acc","hook","forEach","shape","n"],"mappings":"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"}