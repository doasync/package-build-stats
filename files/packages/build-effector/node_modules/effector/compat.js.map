{"version":3,"file":"compat.js","sources":["effector/naming.js","effector/createNode.js","effector/createUnit.js","effector/combine.js","effector/createEffect.js","effector/defer.js","effector/sample.js","effector/restore.js","effector/kernel.js","effector/validate.js","effector/kind.js","effector/throw.js","effector/is.js","effector/getter.js","effector/id.js","effector/bind.js","effector/step.js","effector/stateRef.js","effector/caller.js","effector/own.js","effector/clearNode.js","effector/subscription.js","effector/region.js","effector/forward.js","effector/watch.js","effector/forIn.js","effector/createDomain.js","effector/blocks.js","effector/attach.js","effector/createApi.js","effector/fromObservable.js","effector/guard.js","effector/merge.js","effector/split.js"],"sourcesContent":["//@flow\n\nimport {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //$todo\n  for (const key in objOrArr) {\n    //$todo\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //$todo\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string,\n  fullName: string,\n  path: string[],\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","//@flow\n\nimport {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...list[i])\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = ({hasRef, type, data}, reg) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === 'store') {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>,\n  from?: Graphite | Graphite[],\n  source?: Graphite | Graphite[],\n  parent?: Graphite | Graphite[],\n  to?: Graphite | Graphite[],\n  target?: Graphite | Graphite[],\n  child?: Graphite | Graphite[],\n  scope?: {[name: string]: any},\n  meta?: {[name: string]: any},\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain',\n    links?: Graphite | Graphite[],\n    owners?: Graphite | Graphite[]\n  }\n}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || 'crosslink',\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\n\nimport {is, isObject, isFunction, assertObject} from './is'\nimport {Store, Event, Effect} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, getCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {addToRegion, readTemplate} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {throwError} from './throw'\n\nconst normalizeConfig = (part, config) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentEventHook = (source, target) => {\n  if (getParent(source)) getParent(source).hooks.event(target)\n}\n\nlet isStrict\nexport const initUnit = (kind, unit, rawConfigA, rawConfigB) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const id = nextUnitID()\n  const {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (kind === 'domain' ? '' : id)\n  const compositeName = createName(name, parent)\n  unit.kind = kind\n  unit.id = id\n  unit.sid = sid\n  unit.shortName = name\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = fn => fn(unit)\n  unit.getType = () => compositeName.fullName\n  isStrict = strict\n  return {unit: kind, name, sid, named}\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from, to, op, fn) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event, op, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nexport function createEvent<Payload>(\n  nameOrConfig: any,\n  maybeConfig: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) =>\n    event.create(payload, args, args)\n  event.graphite = createNode({\n    meta: initUnit('event', event, maybeConfig, nameOrConfig),\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (payload, _, args) => {\n    launch(event, payload)\n    return payload\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: Function) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, 'map', fn)\n    return mapped\n  }\n  event.filter = fn => {\n    if (isFunction(fn)) {\n      console.error('.filter(fn) is deprecated, use .filterMap instead')\n      return filterMapEvent(event, fn)\n    }\n    return createEventFiltration(event, 'filter', fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  }\n  event.filterMap = bind(filterMapEvent, event)\n  event.prepend = fn => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentEventHook(event, contramapped)\n    return contramapped\n  }\n  addObservableApi(event, event)\n  const template = readTemplate()\n  if (template) {\n    getGraph(event).meta.nativeTemplate = template\n  }\n  return addToRegion(event)\n}\n\nexport function filterMapEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn?: (val: any) => any,\n): any {\n  return createEventFiltration(event, 'filterMap', fn, [\n    step.compute({fn: callStack}),\n    step.check.defined(),\n  ])\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState)\n  }\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      const currentPage = getCurrentPage()\n      if (!currentPage) return readRef(plainState)\n      if (currentPage.reg[plainState.id])\n        return readRef(currentPage.reg[plainState.id])\n      return readRef(plainState)\n    },\n    setState(state) {\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(events, fn) {\n      if (Array.isArray(events)) {\n        for (const event of events) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(events, fn)\n      }\n      return store\n    },\n    off(unit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, 'map', false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: 'map',\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!template.plain.includes(plainState)) {\n          if (!linkNode.seq.includes(template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    [$$observable]: () => addObservableApi(store, {}),\n  }\n  function onEvent(event, fn) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(updateStore(event, store, 'on', true, fn)),\n    )\n  }\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.update({\n        store: plainState,\n      }),\n      step.check.changed({\n        store: oldState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta: initUnit('store', store, props),\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  if (template) {\n    getGraph(store).meta.nativeTemplate = template\n  }\n  store.watch = store.subscribe = (\n    eventOrFn: Event<any> | Function,\n    fn?: Function,\n  ) => {\n    if (!fn || !is.unit(eventOrFn)) {\n      if (!isFunction(eventOrFn)) throwError('watch requires function handler')\n      const template = readTemplate()\n      if (template) {\n        template.watch.push({\n          of: plainState,\n          fn: eventOrFn,\n        })\n      } else {\n        eventOrFn(store.getState())\n      }\n      return watchUnit(store, eventOrFn)\n    }\n    if (!isFunction(fn)) throwError('second argument should be a function')\n    return eventOrFn.watch(payload => fn(store.getState(), payload))\n  }\n  own(store, [updates])\n  return addToRegion(store)\n}\n\nconst addObservableApi = (unit, target) => {\n  target.subscribe = (observer: Subscriber<any>) => {\n    assertObject(observer)\n    return unit.watch(upd => {\n      if (observer.next) {\n        observer.next(upd)\n      }\n    })\n  }\n  target[$$observable] = () => target\n  return target\n}\n\nconst updateStore = (\n  from,\n  store: Store<any>,\n  op,\n  stateFirst: boolean,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: 'a'}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!template.plain.includes(ref)) {\n        //if (!node.includes(template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!template.closure.includes(ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!node.includes(template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {getStoreState, getConfig, getNestedConfig} from './getter'\nimport {is, isFunction} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './forIn'\n\nexport function combine(...args: any[]): Store<any> {\n  if (args.length === 0) throwError('at least one argument required')\n  let handler\n  let stores\n  let config\n  if (getNestedConfig(args[0])) {\n    config = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = fn => list => fn(...list)\n\nconst storeCombination = (\n  isArray,\n  obj: any,\n  config?: string,\n  fn?: Function,\n) => {\n  const clone = isArray ? list => list.slice() : obj => Object.assign({}, obj)\n  const defaultState = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: 'a',\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: 'a',\n      target: rawShape,\n    }),\n    step.mov({\n      from: 'value',\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: 'barrier'}),\n    step.mov({\n      from: 'value',\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before = (rawShape.before = [])\n  forIn(obj, (child, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!template.plain.includes(childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n        type: 'map',\n        to: getStoreState(store),\n        fn,\n      }\n      : {\n        type: 'copy',\n        to: getStoreState(store),\n      },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","//@flow\n\nimport {Effect} from './unit.h'\nimport {step} from './typedef'\nimport {getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {\n  createNamedEvent,\n  createStore,\n  createEvent,\n  filterMapEvent,\n} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (value => {\n      console.error(`no handler used in ${instance.getType()}`)\n      return Promise.resolve()\n    })\n\n  getGraph(instance).meta.onCopy = ['runner']\n  getGraph(instance).meta.unit = instance.kind = 'effect'\n  instance.use = fn => {\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = filterMapEvent(anyway, {\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = filterMapEvent(anyway, {\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: (instance.use.getCurrent = () => handler),\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, {page}) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  getGraph(instance).scope.runner = effectRunner\n  getGraph(instance).seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    launch(instance, {params, req})\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({params, req, ok, anyway, page}) => data =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n          status: 'done',\n          params,\n          result: data,\n        }\n        : {\n          status: 'fail',\n          params,\n          error: data,\n        },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page,\n  })\n\nconst sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","//@flow\n\nexport function createDefer(): {\n  rs: (value: any) => any,\n  rj: (value: any) => any,\n  req: Promise<any>,\n  } {\n  const result = {}\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","//@flow\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {getStoreState, getConfig, getNestedConfig, getGraph} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {addToRegion, readTemplate} from './region'\nimport {throwError} from './throw'\n\nexport const shapeToStore = shape => (is.unit(shape) ? shape : combine(shape))\n\nexport function sample(...args): any {\n  let target\n  let name\n  let metadata\n  if (getNestedConfig(args[0])) {\n    metadata = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  let [source, clock, fn, greedy = false] = args\n\n  //config case\n  if (clock === undefined && 'source' in source) {\n    if ('clock' in source && source.clock == null)\n      throwError('config.clock should be defined')\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  name = metadata || name || source.shortName\n  source = shapeToStore(source)\n  clock = shapeToStore(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = null\n  }\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate = isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({\n            store: getStoreState(source),\n            to: fn ? 'a' : 'stack',\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'store'},\n      }),\n    ])\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    addToRegion(\n      createNode({\n        parent: source,\n        node: [\n          step.update({store: sourceState}),\n          step.mov({\n            from: 'value',\n            store: true,\n            target: hasSource,\n          }),\n        ],\n        family: {\n          owners: [source, target, clock],\n          links: target,\n        },\n        meta: {op: 'sample', sample: 'source'},\n      }),\n    )\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: 'a',\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","//@flow\nimport {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_, {result}) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result = {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n\nexport {\n  restore as restoreEvent,\n  restore as restoreEffect,\n  restore as restoreObject,\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\nimport {readRef} from './stateRef'\nimport {getGraph, getValue} from './getter'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Graph\n */\ntype Layer = {\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number,\n}\n\n/** Call stack */\ntype Stack = {\n  value: any,\n  a: any,\n  b: any,\n  parent: Stack | null,\n  node: Graph,\n  page: {[id: string]: any} | null,\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer,\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null,\n  /** right node */\n  r: QueueItem | null,\n}\ntype QueueBucket = {\n  first: QueueItem | null,\n  last: QueueItem | null,\n  size: number,\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean,\n  scope: {[key: string]: any},\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === 'sampler')\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap.v\n        heap = merge(heap.l, heap.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item.r\n      list.size -= 1\n      return item.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Graph,\n  parent: Stack | null,\n  value: any,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: 0,\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'barrier':\n      return 2\n    case 'sampler':\n      return 3\n    case 'effect':\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet alreadyStarted = false\nlet currentPage = null\nexport const getCurrentPage = () => currentPage\n\n/** main execution method */\nconst exec = () => {\n  const lastStartedState = {alreadyStarted, currentPage}\n  alreadyStarted = true\n  let stop\n  let skip\n  let graph\n  let value\n  let page\n  let reg\n  mem: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    graph = stack.node\n    currentPage = page = stack.page\n    reg = (page ? page : graph).reg\n    const local: Local = {\n      fail: false,\n      scope: graph.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < graph.seq.length && !stop; stepn++) {\n      const step = graph.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case 'barrier': {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue mem\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': value = stack.a; break\n            case 'b': value = stack.b; break\n            case 'value': value = data.store; break\n            case 'store':\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = null\n                reg = graph.reg\n                // }\n              }\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': stack.a = value; break\n            case 'b': stack.b = value; break\n            case 'store':\n              reg[data.target.id].current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip = getValue(stack) === readRef(reg[data.store.id])\n              break\n          }\n          break\n        case 'filter':\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== 'effect') {\n            pushHeap(stepn, stack, 'effect')\n            continue mem\n          }\n        case 'compute':\n          stack.value = tryRun(local, data, stack)\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < graph.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          graph.next[stepn],\n          stack,\n          getValue(stack),\n        )\n      }\n    }\n  }\n  alreadyStarted = lastStartedState.alreadyStarted\n  currentPage = lastStartedState.currentPage\n}\nexport const launch = (unit: Graphite, payload: any, upsert?: boolean) => {\n  let page = currentPage\n  let stack = null\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    page = 'page' in unit ? unit.page : page\n    if (unit.stack) stack = unit.stack\n    unit = unit.target\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem('pure', page, getGraph(unit[i]), stack, payload[i])\n    }\n  } else {\n    pushFirstHeapItem('pure', page, getGraph(unit), stack, payload)\n  }\n  if (upsert && alreadyStarted) return\n  exec()\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","//@flow\n\nimport {kind} from './index.h'\nimport {\n  store as storeKind,\n  event as eventKind,\n  effect as effectKind,\n  domain as domainKind,\n} from './kind'\n\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: mixed) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(storeKind)\nexport const event = is(eventKind)\nexport const effect = is(effectKind)\nexport const domain = is(domainKind)\n","//@flow\n\nimport {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const throwError = (message: string) => {\n  throw Error(message)\n}\n","//@flow\n\n//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect value to be an object') // or function\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\n\nexport const getGraph = (graph: Graphite): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = store => store.stateRef\nexport const getConfig = opts => opts.config\nexport const getNestedConfig = opts => opts.ɔ\nexport const getValue = stack => stack.value\nexport const getSubscribers = store => store.subscribers\nexport const getParent = unit => unit.parent\n","//@flow\n\nconst idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\n","//@flow\n\nexport const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","//@flow\nimport {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {\n  priority?: 'barrier' | 'sampler',\n}) => Barrier = ({priority = 'barrier'}) =>\n  cmd('barrier', false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b',\n  to?: 'stack' | 'a' | 'b',\n  store?: any,\n  target?: any,\n}) => Mov = ({\n  from = 'store',\n  store,\n  target,\n  to = target ? 'store' : 'stack',\n}) => cmd('mov', from === 'store', {from, store, to, target})\nexport const check: {\n  defined(): Check,\n  changed({store: StateRef}): Check,\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Filter = bind2(cmd, 'filter', false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {\n  store: StateRef,\n}) => Mov = ({store}) => mov({from: 'stack', target: store})\n","//@flow\n\nimport {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","//@flow\n\nexport const callStackAReg = (stack, {fn}, {a}) => fn(stack, a)\nexport const callARegStack = (stack, {fn}, {a}) => fn(a, stack)\nexport const callStack = (stack, {fn}) => fn(stack)\n","//@flow\n\nimport {Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nexport const own = (ownerUnit: Graphite, links: Graphite[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== 'domain') link.family.type = 'crosslink'\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","//@flow\n\nimport {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\n\nconst removeItem = (list, item) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\nconst removeFromNode = (currentNode, targetNode) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //$off\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === 'crosslink'\n    ) {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === 'crosslink') {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean,\n  } = {},\n) => {\n  let isDomainUnit = false\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","//@flow\n\nimport {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","//@flow\nimport {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\n\nexport const addToRegion = unit => {\n  if (regionStack) own(getValue(regionStack), [unit])\n  return unit\n}\n\nlet regionStack = null\n\nexport const readTemplate = () => regionStack && regionStack.template\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template:\n      getGraph(unit).meta.template || (regionStack && regionStack.template),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n","//@flow\nimport {getConfig, getNestedConfig} from './getter'\nimport {createNode} from './createNode'\nimport {Subscription, Graphite, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {addToRegion} from './region'\n\nexport const createLinkNode = (\n  parent: Graphite,\n  child: Graphite,\n  {\n    node,\n    scope,\n    meta\n  }: {\n    node?: Array<Cmd | false | void | null>,\n    scope?: {[name: string]: any},\n    meta?: {[name: string]: any}\n  }\n) =>\n  addToRegion(\n    createNode({\n      node,\n      parent,\n      child,\n      scope,\n      meta,\n      family: {\n        owners: [parent, child],\n        links: child,\n      },\n    }),\n  )\nexport const forward = (opts: {\n  from: Graphite | Graphite[],\n  to: Graphite | Graphite[],\n  meta?: Object,\n}): Subscription => {\n  let config\n  if (getNestedConfig(opts)) {\n    config = getConfig(opts)\n    opts = getNestedConfig(opts)\n  }\n  const {from, to, meta = {op: 'forward'}} = opts\n  if (!from || !to) throwError('from and to fields should be defined')\n  if (config) meta.config = config\n  return createSubscription(\n    addToRegion(\n      createNode({\n        parent: from,\n        child: to,\n        meta,\n        family: {},\n      }),\n    ),\n  )\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription =>\n  createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n","//@flow\n\nexport const forIn = (obj, cb: (value: any, key: string) => void) => {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n","//@flow\n\nimport {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {addToRegion} from './region'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node) => {\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: 'domain'},\n  })\n\n  const result = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit('domain', result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  addToRegion(result)\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {readRef} from './stateRef'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== undefined &&\n    data !== readRef(state)\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n","//@flow\n\nimport {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentEventHook} from './createUnit'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\n\nexport function attach({source, effect, mapParams}) {\n  const attached = createEffect()\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req},\n    {finally: anyway, effect},\n    {a: states, page},\n  ) =>\n    launch({\n      target: effect,\n      params: {\n        params: mapParams(params, states),\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          }),\n          rj: onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          }),\n        },\n      },\n      page,\n      defer: true,\n    })\n\n  if (source) {\n    let state\n    if (is.store(source)) state = source\n    else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: 'store',\n      store: getStoreState(state),\n      to: 'a',\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  runner.scope.effect = effect\n  runner.meta.onCopy.push('effect')\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentEventHook(effect, attached)\n  return attached\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createEvent, applyParentEventHook} from './createUnit'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function createApi(\n  store: Store<any>,\n  setters: {[key: string]: Function},\n) {\n  const result = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {parent: getParent(store)}))\n    store.on(event, fn)\n    applyParentEventHook(store, event)\n  })\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    $$observable in observable ? observable[$$observable]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event: Event<T> = createEvent()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\n\nimport {getConfig, getNestedConfig} from './getter'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\n\nexport function guard(source, config) {\n  const meta = {op: 'guard'}\n  if (getNestedConfig(source)) {\n    meta.config = getConfig(source)\n    ;[source, config] = getNestedConfig(source)\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  const {filter, greedy, name = 'guard'} = config\n  const target = config.target || createEvent(name)\n  if (!is.unit(source)) source = combine(source)\n\n  if (is.unit(filter)) {\n    sample({\n      source: filter,\n      clock: source,\n      target: addToRegion(\n        createNode({\n          node: [\n            step.filter({\n              fn: ({guard}) => guard,\n            }),\n            step.compute({\n              fn: ({data}) => data,\n            }),\n          ],\n          child: target,\n          meta,\n          family: {\n            owners: [source, filter, target],\n            links: target,\n          },\n        }),\n      ),\n      fn: (guard, data) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","// @flow\n\nimport {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\n\nexport function merge<T>(\n  events: $ReadOnlyArray<Event<T> | Store<T> | Effect<T, any, any>>,\n): Event<T> {\n  const result = createEvent(unitObjectName(events, 'merge'))\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","//@flow\nimport {Event} from './unit.h'\nimport {is} from './is'\nimport {forIn} from './forIn'\n\nexport function split<S>(\n  unit: Event<S>,\n  cases: {[key: string]: (s: S) => boolean}\n): {[key: string]: Event<S>} {\n  const result = {}\n  let current: Event<S> = is.store(unit) ? unit.updates : unit\n  forIn(cases, (fn, key) => {\n    result[key] = current.filter({fn})\n    current = current.filter({\n      fn: data => !fn(data),\n    })\n  })\n  result.__ = current\n  return result\n}\n"],"names":["unitObjectName","objOrArr","method","name","comma","i","key","unit","is","compositeName","fullName","toString","createName","parent","path","composite","shortName","length","concat","createNode","node","child","to","target","scope","meta","family","familyRaw","type","sources","arrifyNodes","from","source","links","owners","seq","reg","item","push","addToReg","result","next","getOwners","getLinks","createEvent","nameOrConfig","maybeConfig","event","payload","args","create","graphite","initUnit","launch","watch","bind","watchUnit","map","fn","config","isObject","mapped","mapName","createComputation","filter","isFunction","console","error","filterMapEvent","createEventFiltration","step","callStack","filterMap","prepend","contramapped","getParent","template","readTemplate","getGraph","upward","applyParentEventHook","addObservableApi","nativeTemplate","addToRegion","defined","createStore","defaultState","props","onEvent","store","off","getSubscribers","set","createSubscription","updateStore","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","subscribers","Map","stateRef","getState","currentPage","getCurrentPage","readRef","id","setState","state","params","defer","reset","units","on","events","Array","isArray","currentSubscription","get","delete","firstState","lastResult","storeState","undefined","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","$$observable","changed","isStrict","throwError","subscribe","eventOrFn","of","own","combine","handler","stores","getNestedConfig","getConfig","structStoreShape","shapeReady","rawHandler","slice","obj","spreadArgs","storeCombination","createEffect","instance","defaultConfig","getType","Promise","resolve","onCopy","kind","use","anyway","finally","done","named","status","fail","doneData","failData","effectRunner","getHandler","getCurrent","req","page","onResolve","onSettled","ok","onReject","err","then","op","fx","runner","stack","rs","rj","upd","catch","inFlight","x","pending","amount","sample","metadata","clock","greedy","shapeToStore","isUpward","initialState","targetTemplate","createLinkNode","priority","callARegStack","hasSource","sourceState","clockState","callStackAReg","restore","domain","ɔ","_","v","hooks","forIn","value","effect","message","Error","assertObject","graph","opts","getValue","joinName","tag","idCount","nextUnitID","nextStepID","bind2","arg","cmd","hasRef","data","nextBarrierID","barrier","barrierID","mov","check","compute","run","update","current","a","ownerUnit","owner","link","list","heap","merge","b","ret","isSameType","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","pushHeap","idx","getPriority","bucket","t","barriers","Set","alreadyStarted","upsert","stop","skip","lastStartedState","mem","local","stepn","fullID","has","add","tryRun","exec","removeItem","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearMap","clear","clearNode","deep","isDomainUnit","ownerSet","history","effects","domains","clearNodeNormalized","pop","unsubscribe","regionStack","forward","rawConfigA","rawConfigB","normalizeConfig","part","loc","sid","thru","observer","stateFirst","storeRef","ref","closure","cb","clone","Object","assign","stateNew","rawShape","isFresh","childRef","field","defaultShape","sidechain","createHook","trigger","acc","hook","forEach","shape","n","runnerSteps","mapParams","attached","runnerFn","readStateRef","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","observable","observableItem","disposer","complete","guard","rawName","currentComposite","cases","__"],"mappings":"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"}