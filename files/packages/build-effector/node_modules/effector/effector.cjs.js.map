{"version":3,"file":"effector.cjs.js","sources":["effector/naming.js","effector/createNode.js","effector/createUnit.js","effector/combine.js","effector/createEffect.js","effector/defer.js","effector/sample.js","effector/restore.js","effector/validate.js","effector/kind.js","effector/throw.js","effector/is.js","effector/getter.js","effector/id.js","effector/bind.js","effector/step.js","effector/stateRef.js","effector/caller.js","effector/own.js","effector/kernel.js","effector/clearNode.js","effector/subscription.js","effector/region.js","effector/forward.js","effector/watch.js","effector/forIn.js","effector/createDomain.js","effector/blocks.js","effector/attach.js","effector/createApi.js","effector/fromObservable.js","effector/guard.js","effector/merge.js","effector/split.js"],"sourcesContent":["//@flow\n\nimport {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //$todo\n  for (const key in objOrArr) {\n    //$todo\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //$todo\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string,\n  fullName: string,\n  path: string[],\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","//@flow\n\nimport {Graph, Graphite, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nconst arrifyNodes = (list: Graphite | Graphite[] = []): Graph[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...list[i])\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = ({hasRef, type, data}, reg) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === 'store') {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n}: {\n  node?: Array<Cmd | false | void | null>,\n  from?: Graphite | Graphite[],\n  source?: Graphite | Graphite[],\n  parent?: Graphite | Graphite[],\n  to?: Graphite | Graphite[],\n  target?: Graphite | Graphite[],\n  child?: Graphite | Graphite[],\n  scope?: {[name: string]: any},\n  meta?: {[name: string]: any},\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain',\n    links?: Graphite | Graphite[],\n    owners?: Graphite | Graphite[]\n  }\n}): Graph {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Graph = {\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || 'crosslink',\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\n\nimport {is, isObject, isFunction, assertObject} from './is'\nimport {Store, Event, Effect} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, getCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {addToRegion, readTemplate} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {throwError} from './throw'\n\nconst normalizeConfig = (part, config) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentEventHook = (source, target) => {\n  if (getParent(source)) getParent(source).hooks.event(target)\n}\n\nlet isStrict\nexport const initUnit = (kind, unit, rawConfigA, rawConfigB) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const id = nextUnitID()\n  const {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (kind === 'domain' ? '' : id)\n  const compositeName = createName(name, parent)\n  unit.kind = kind\n  unit.id = id\n  unit.sid = sid\n  unit.shortName = name\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = fn => fn(unit)\n  unit.getType = () => compositeName.fullName\n  isStrict = strict\n  return {unit: kind, name, sid, named}\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from, to, op, fn) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event, op, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nexport function createEvent<Payload>(\n  nameOrConfig: any,\n  maybeConfig: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) =>\n    event.create(payload, args, args)\n  event.graphite = createNode({\n    meta: initUnit('event', event, maybeConfig, nameOrConfig),\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (payload, _, args) => {\n    launch(event, payload)\n    return payload\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: Function) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, 'map', fn)\n    return mapped\n  }\n  event.filter = fn => {\n    if (isFunction(fn)) {\n      console.error('.filter(fn) is deprecated, use .filterMap instead')\n      return filterMapEvent(event, fn)\n    }\n    return createEventFiltration(event, 'filter', fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  }\n  event.filterMap = bind(filterMapEvent, event)\n  event.prepend = fn => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentEventHook(event, contramapped)\n    return contramapped\n  }\n  addObservableApi(event, event)\n  const template = readTemplate()\n  if (template) {\n    getGraph(event).meta.nativeTemplate = template\n  }\n  return addToRegion(event)\n}\n\nexport function filterMapEvent(\n  event: Event<any> | Effect<any, any, any>,\n  fn?: (val: any) => any,\n): any {\n  return createEventFiltration(event, 'filterMap', fn, [\n    step.compute({fn: callStack}),\n    step.check.defined(),\n  ])\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState)\n  }\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      const currentPage = getCurrentPage()\n      if (!currentPage) return readRef(plainState)\n      if (currentPage.reg[plainState.id])\n        return readRef(currentPage.reg[plainState.id])\n      return readRef(plainState)\n    },\n    setState(state) {\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(events, fn) {\n      if (Array.isArray(events)) {\n        for (const event of events) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(events, fn)\n      }\n      return store\n    },\n    off(unit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, 'map', false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: 'map',\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!template.plain.includes(plainState)) {\n          if (!linkNode.seq.includes(template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    [$$observable]: () => addObservableApi(store, {}),\n  }\n  function onEvent(event, fn) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(updateStore(event, store, 'on', true, fn)),\n    )\n  }\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.update({\n        store: plainState,\n      }),\n      step.check.changed({\n        store: oldState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta: initUnit('store', store, props),\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  if (template) {\n    getGraph(store).meta.nativeTemplate = template\n  }\n  store.watch = store.subscribe = (\n    eventOrFn: Event<any> | Function,\n    fn?: Function,\n  ) => {\n    if (!fn || !is.unit(eventOrFn)) {\n      if (!isFunction(eventOrFn)) throwError('watch requires function handler')\n      const template = readTemplate()\n      if (template) {\n        template.watch.push({\n          of: plainState,\n          fn: eventOrFn,\n        })\n      } else {\n        eventOrFn(store.getState())\n      }\n      return watchUnit(store, eventOrFn)\n    }\n    if (!isFunction(fn)) throwError('second argument should be a function')\n    return eventOrFn.watch(payload => fn(store.getState(), payload))\n  }\n  own(store, [updates])\n  return addToRegion(store)\n}\n\nconst addObservableApi = (unit, target) => {\n  target.subscribe = (observer: Subscriber<any>) => {\n    assertObject(observer)\n    return unit.watch(upd => {\n      if (observer.next) {\n        observer.next(upd)\n      }\n    })\n  }\n  target[$$observable] = () => target\n  return target\n}\n\nconst updateStore = (\n  from,\n  store: Store<any>,\n  op,\n  stateFirst: boolean,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: 'a'}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!template.plain.includes(ref)) {\n        //if (!node.includes(template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!template.closure.includes(ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!node.includes(template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {getStoreState, getConfig, getNestedConfig} from './getter'\nimport {is, isFunction} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './forIn'\n\nexport function combine(...args: any[]): Store<any> {\n  if (args.length === 0) throwError('at least one argument required')\n  let handler\n  let stores\n  let config\n  if (getNestedConfig(args[0])) {\n    config = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = fn => list => fn(...list)\n\nconst storeCombination = (\n  isArray,\n  obj: any,\n  config?: string,\n  fn?: Function,\n) => {\n  const clone = isArray ? list => list.slice() : obj => Object.assign({}, obj)\n  const defaultState = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: 'a',\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: 'a',\n      target: rawShape,\n    }),\n    step.mov({\n      from: 'value',\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: 'barrier'}),\n    step.mov({\n      from: 'value',\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before = (rawShape.before = [])\n  forIn(obj, (child, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!template.plain.includes(childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n        type: 'map',\n        to: getStoreState(store),\n        fn,\n      }\n      : {\n        type: 'copy',\n        to: getStoreState(store),\n      },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","//@flow\n\nimport {Effect} from './unit.h'\nimport {step} from './typedef'\nimport {getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {\n  createNamedEvent,\n  createStore,\n  createEvent,\n  filterMapEvent,\n} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (value => {\n      console.error(`no handler used in ${instance.getType()}`)\n      return Promise.resolve()\n    })\n\n  getGraph(instance).meta.onCopy = ['runner']\n  getGraph(instance).meta.unit = instance.kind = 'effect'\n  instance.use = fn => {\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = filterMapEvent(anyway, {\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = filterMapEvent(anyway, {\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: (instance.use.getCurrent = () => handler),\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, {page}) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  getGraph(instance).scope.runner = effectRunner\n  getGraph(instance).seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data) {},\n            rj(data) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    launch(instance, {params, req})\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({params, req, ok, anyway, page}) => data =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n          status: 'done',\n          params,\n          result: data,\n        }\n        : {\n          status: 'fail',\n          params,\n          error: data,\n        },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page,\n  })\n\nconst sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","//@flow\n\nexport function createDefer(): {\n  rs: (value: any) => any,\n  rj: (value: any) => any,\n  req: Promise<any>,\n  } {\n  const result = {}\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","//@flow\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {getStoreState, getConfig, getNestedConfig, getGraph} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {addToRegion, readTemplate} from './region'\nimport {throwError} from './throw'\n\nexport const shapeToStore = shape => (is.unit(shape) ? shape : combine(shape))\n\nexport function sample(...args): any {\n  let target\n  let name\n  let metadata\n  if (getNestedConfig(args[0])) {\n    metadata = getConfig(args[0])\n    args = getNestedConfig(args[0])\n  }\n  let [source, clock, fn, greedy = false] = args\n\n  //config case\n  if (clock === undefined && 'source' in source) {\n    if ('clock' in source && source.clock == null)\n      throwError('config.clock should be defined')\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    source = source.source\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  name = metadata || name || source.shortName\n  source = shapeToStore(source)\n  clock = shapeToStore(clock)\n  if (typeof fn === 'boolean') {\n    greedy = fn\n    fn = null\n  }\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate = isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({\n            store: getStoreState(source),\n            to: fn ? 'a' : 'stack',\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'store'},\n      }),\n    ])\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    addToRegion(\n      createNode({\n        parent: source,\n        node: [\n          step.update({store: sourceState}),\n          step.mov({\n            from: 'value',\n            store: true,\n            target: hasSource,\n          }),\n        ],\n        family: {\n          owners: [source, target, clock],\n          links: target,\n        },\n        meta: {op: 'sample', sample: 'source'},\n      }),\n    )\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //$off\n          !greedy && step.barrier({priority: 'sampler'}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: 'a',\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward\n        ],\n        meta: {op: 'sample', sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","//@flow\nimport {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_, {result}) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result = {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n\nexport {\n  restore as restoreEvent,\n  restore as restoreEffect,\n  restore as restoreObject,\n}\n","//@flow\n\nimport {kind} from './index.h'\nimport {\n  store as storeKind,\n  event as eventKind,\n  effect as effectKind,\n  domain as domainKind,\n} from './kind'\n\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: mixed) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: mixed) => unit(obj) && obj.kind === type\n\nexport const store = is(storeKind)\nexport const event = is(eventKind)\nexport const effect = is(effectKind)\nexport const domain = is(domainKind)\n","//@flow\n\nimport {kind} from './index.h'\n\nexport const store: kind = 'store'\nexport const event: kind = 'event'\nexport const effect: kind = 'effect'\nexport const domain: kind = 'domain'\n","//@flow\n\nexport const throwError = (message: string) => {\n  throw Error(message)\n}\n","//@flow\n\n//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect value to be an object') // or function\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\n\nexport const getGraph = (graph: Graphite): Graph => graph.graphite || graph\nexport const getOwners = (node: Graph) => node.family.owners\nexport const getLinks = (node: Graph) => node.family.links\nexport const getStoreState = store => store.stateRef\nexport const getConfig = opts => opts.config\nexport const getNestedConfig = opts => opts.ɔ\nexport const getValue = stack => stack.value\nexport const getSubscribers = store => store.subscribers\nexport const getParent = unit => unit.parent\n","//@flow\n\nconst idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\n","//@flow\n\nexport const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","//@flow\nimport {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {\n  priority?: 'barrier' | 'sampler',\n}) => Barrier = ({priority = 'barrier'}) =>\n  cmd('barrier', false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b',\n  to?: 'stack' | 'a' | 'b',\n  store?: any,\n  target?: any,\n}) => Mov = ({\n  from = 'store',\n  store,\n  target,\n  to = target ? 'store' : 'stack',\n}) => cmd('mov', from === 'store', {from, store, to, target})\nexport const check: {\n  defined(): Check,\n  changed({store: StateRef}): Check,\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Filter = bind2(cmd, 'filter', false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {\n  store: StateRef,\n}) => Mov = ({store}) => mov({from: 'stack', target: store})\n","//@flow\n\nimport {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","//@flow\n\nexport const callStackAReg = (stack, {fn}, {a}) => fn(stack, a)\nexport const callARegStack = (stack, {fn}, {a}) => fn(a, stack)\nexport const callStack = (stack, {fn}) => fn(stack)\n","//@flow\n\nimport {Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\n\nexport const own = (ownerUnit: Graphite, links: Graphite[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== 'domain') link.family.type = 'crosslink'\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","//@flow\n\nimport {Graphite, Graph} from './index.h'\nimport {readRef} from './stateRef'\nimport {getGraph, getValue} from './getter'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Graph\n */\ntype Layer = {\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number,\n}\n\n/** Call stack */\ntype Stack = {\n  value: any,\n  a: any,\n  b: any,\n  parent: Stack | null,\n  node: Graph,\n  page: {[id: string]: any} | null,\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer,\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null,\n  /** right node */\n  r: QueueItem | null,\n}\ntype QueueBucket = {\n  first: QueueItem | null,\n  last: QueueItem | null,\n  size: number,\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean,\n  scope: {[key: string]: any},\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === 'sampler')\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap.v\n        heap = merge(heap.l, heap.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item.r\n      list.size -= 1\n      return item.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Graph,\n  parent: Stack | null,\n  value: any,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: 0,\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'barrier':\n      return 2\n    case 'sampler':\n      return 3\n    case 'effect':\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet alreadyStarted = false\nlet currentPage = null\nexport const getCurrentPage = () => currentPage\n\n/** main execution method */\nconst exec = () => {\n  const lastStartedState = {alreadyStarted, currentPage}\n  alreadyStarted = true\n  let stop\n  let skip\n  let graph\n  let value\n  let page\n  let reg\n  mem: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    graph = stack.node\n    currentPage = page = stack.page\n    reg = (page ? page : graph).reg\n    const local: Local = {\n      fail: false,\n      scope: graph.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < graph.seq.length && !stop; stepn++) {\n      const step = graph.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case 'barrier': {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue mem\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case 'stack': value = getValue(stack); break\n            case 'a': value = stack.a; break\n            case 'b': value = stack.b; break\n            case 'value': value = data.store; break\n            case 'store':\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = null\n                reg = graph.reg\n                // }\n              }\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case 'stack': stack.value = value; break\n            case 'a': stack.a = value; break\n            case 'b': stack.b = value; break\n            case 'store':\n              reg[data.target.id].current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip = getValue(stack) === readRef(reg[data.store.id])\n              break\n          }\n          break\n        case 'filter':\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== 'effect') {\n            pushHeap(stepn, stack, 'effect')\n            continue mem\n          }\n        case 'compute':\n          stack.value = tryRun(local, data, stack)\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < graph.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          graph.next[stepn],\n          stack,\n          getValue(stack),\n        )\n      }\n    }\n  }\n  alreadyStarted = lastStartedState.alreadyStarted\n  currentPage = lastStartedState.currentPage\n}\nexport const launch = (unit: Graphite, payload: any, upsert?: boolean) => {\n  let page = currentPage\n  let stack = null\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    page = 'page' in unit ? unit.page : page\n    if (unit.stack) stack = unit.stack\n    unit = unit.target\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem('pure', page, getGraph(unit[i]), stack, payload[i])\n    }\n  } else {\n    pushFirstHeapItem('pure', page, getGraph(unit), stack, payload)\n  }\n  if (upsert && alreadyStarted) return\n  exec()\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","//@flow\n\nimport {Graph, Graphite} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\n\nconst removeItem = (list, item) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\nconst removeFromNode = (currentNode, targetNode) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Graph,\n  deep: boolean,\n  isDomainUnit,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //$off\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === 'crosslink'\n    ) {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === 'crosslink') {\n      clearNodeNormalized(currentNode, deep, isDomainUnit)\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: Graphite,\n  {\n    deep,\n  }: {\n    deep?: boolean,\n  } = {},\n) => {\n  let isDomainUnit = false\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","//@flow\n\nimport {Subscription, Graphite} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: Graphite): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","//@flow\nimport {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\n\nexport const addToRegion = unit => {\n  if (regionStack) own(getValue(regionStack), [unit])\n  return unit\n}\n\nlet regionStack = null\n\nexport const readTemplate = () => regionStack && regionStack.template\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template:\n      getGraph(unit).meta.template || (regionStack && regionStack.template),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n","//@flow\nimport {getConfig, getNestedConfig} from './getter'\nimport {createNode} from './createNode'\nimport {Subscription, Graphite, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {addToRegion} from './region'\n\nexport const createLinkNode = (\n  parent: Graphite,\n  child: Graphite,\n  {\n    node,\n    scope,\n    meta\n  }: {\n    node?: Array<Cmd | false | void | null>,\n    scope?: {[name: string]: any},\n    meta?: {[name: string]: any}\n  }\n) =>\n  addToRegion(\n    createNode({\n      node,\n      parent,\n      child,\n      scope,\n      meta,\n      family: {\n        owners: [parent, child],\n        links: child,\n      },\n    }),\n  )\nexport const forward = (opts: {\n  from: Graphite | Graphite[],\n  to: Graphite | Graphite[],\n  meta?: Object,\n}): Subscription => {\n  let config\n  if (getNestedConfig(opts)) {\n    config = getConfig(opts)\n    opts = getNestedConfig(opts)\n  }\n  const {from, to, meta = {op: 'forward'}} = opts\n  if (!from || !to) throwError('from and to fields should be defined')\n  if (config) meta.config = config\n  return createSubscription(\n    addToRegion(\n      createNode({\n        parent: from,\n        child: to,\n        meta,\n        family: {},\n      }),\n    ),\n  )\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, Unit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {addToRegion} from './region'\n\nexport const watchUnit = (\n  unit: Unit,\n  handler: (payload: any) => any,\n): Subscription =>\n  createSubscription(\n    addToRegion(\n      createNode({\n        scope: {fn: handler},\n        node: [step.run({fn: callStack})],\n        parent: unit,\n        meta: {op: 'watch'},\n        family: {\n          owners: unit,\n        },\n      }),\n    ),\n  )\n","//@flow\n\nexport const forIn = (obj, cb: (value: any, key: string) => void) => {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n","//@flow\n\nimport {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {addToRegion} from './region'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node) => {\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: 'domain'},\n  })\n\n  const result = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit('domain', result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  addToRegion(result)\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","//@flow\n\nimport {step} from './typedef'\nimport {readRef} from './stateRef'\n\n//prettier-ignore\nexport const filterChanged = step.filter({\n  fn: (data, {state}) => (\n    data !== undefined &&\n    data !== readRef(state)\n  ),\n})\n\nexport const noop = step.compute({\n  fn: n => n,\n})\n","//@flow\n\nimport {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentEventHook} from './createUnit'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\n\nexport function attach({source, effect, mapParams}) {\n  const attached = createEffect()\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req},\n    {finally: anyway, effect},\n    {a: states, page},\n  ) =>\n    launch({\n      target: effect,\n      params: {\n        params: mapParams(params, states),\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            page,\n          }),\n          rj: onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            page,\n          }),\n        },\n      },\n      page,\n      defer: true,\n    })\n\n  if (source) {\n    let state\n    if (is.store(source)) state = source\n    else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: 'store',\n      store: getStoreState(state),\n      to: 'a',\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  runner.scope.effect = effect\n  runner.meta.onCopy.push('effect')\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentEventHook(effect, attached)\n  return attached\n}\n","//@flow\n\nimport {Store} from './unit.h'\nimport {createEvent, applyParentEventHook} from './createUnit'\nimport {forIn} from './forIn'\nimport {getParent} from './getter'\n\nexport function createApi(\n  store: Store<any>,\n  setters: {[key: string]: Function},\n) {\n  const result = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {parent: getParent(store)}))\n    store.on(event, fn)\n    applyParentEventHook(store, event)\n  })\n  return result\n}\n","//@flow\n\nimport $$observable from 'symbol-observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: mixed): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    $$observable in observable ? observable[$$observable]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event: Event<T> = createEvent()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","//@flow\n\nimport {getConfig, getNestedConfig} from './getter'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {addToRegion} from './region'\nimport {throwError} from './throw'\n\nexport function guard(source, config) {\n  const meta = {op: 'guard'}\n  if (getNestedConfig(source)) {\n    meta.config = getConfig(source)\n    ;[source, config] = getNestedConfig(source)\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  const {filter, greedy, name = 'guard'} = config\n  const target = config.target || createEvent(name)\n  if (!is.unit(source)) source = combine(source)\n\n  if (is.unit(filter)) {\n    sample({\n      source: filter,\n      clock: source,\n      target: addToRegion(\n        createNode({\n          node: [\n            step.filter({\n              fn: ({guard}) => guard,\n            }),\n            step.compute({\n              fn: ({data}) => data,\n            }),\n          ],\n          child: target,\n          meta,\n          family: {\n            owners: [source, filter, target],\n            links: target,\n          },\n        }),\n      ),\n      fn: (guard, data) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","// @flow\n\nimport {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\n\nexport function merge<T>(\n  events: $ReadOnlyArray<Event<T> | Store<T> | Effect<T, any, any>>,\n): Event<T> {\n  const result = createEvent(unitObjectName(events, 'merge'))\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","//@flow\nimport {Event} from './unit.h'\nimport {is} from './is'\nimport {forIn} from './forIn'\n\nexport function split<S>(\n  unit: Event<S>,\n  cases: {[key: string]: (s: S) => boolean}\n): {[key: string]: Event<S>} {\n  const result = {}\n  let current: Event<S> = is.store(unit) ? unit.updates : unit\n  forIn(cases, (fn, key) => {\n    result[key] = current.filter({fn})\n    current = current.filter({\n      fn: data => !fn(data),\n    })\n  })\n  result.__ = current\n  return result\n}\n"],"names":["unitObjectName","objOrArr","method","name","comma","i","key","unit","is","compositeName","fullName","toString","createName","parent","path","composite","shortName","length","concat","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","sources","arrifyNodes","links","owners","seq","reg","item","push","addToReg","result","next","getOwners","getLinks","createEvent","nameOrConfig","maybeConfig","event","payload","args","create","graphite","initUnit","launch","watch","bind","watchUnit","map","fn","config","isObject","mapped","mapName","createComputation","filter","isFunction","console","error","filterMapEvent","createEventFiltration","step","callStack","filterMap","prepend","contramapped","getParent","template","readTemplate","getGraph","upward","applyParentEventHook","addObservableApi","nativeTemplate","addToRegion","defined","createStore","defaultState","props","onEvent","store","off","getSubscribers","set","createSubscription","updateStore","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","subscribers","Map","stateRef","getState","currentPage","getCurrentPage","readRef","id","setState","state","params","defer","reset","units","on","events","Array","isArray","currentSubscription","get","delete","firstState","lastResult","storeState","undefined","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","$$observable","changed","isStrict","throwError","subscribe","eventOrFn","of","own","combine","handler","stores","getNestedConfig","getConfig","structStoreShape","shapeReady","rawHandler","slice","obj","spreadArgs","storeCombination","createEffect","instance","defaultConfig","getType","Promise","resolve","onCopy","kind","use","anyway","finally","done","named","status","fail","doneData","failData","effectRunner","getHandler","getCurrent","req","page","onResolve","onSettled","ok","onReject","err","then","op","fx","runner","stack","rs","data","rj","upd","catch","createDefer","inFlight","x","pending","amount","sample","metadata","clock","greedy","shapeToStore","isUpward","targetTemplate","createLinkNode","priority","callARegStack","hasSource","sourceState","clockState","callStackAReg","restore","domain","ɔ","_","v","hooks","forIn","value","effect","message","Error","assertObject","graph","opts","getValue","joinName","tag","idCount","nextUnitID","nextStepID","bind2","arg","cmd","hasRef","nextBarrierID","barrier","barrierID","mov","check","compute","run","update","current","a","ownerUnit","owner","link","list","heap","merge","b","ret","isSameType","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","pushHeap","idx","getPriority","bucket","t","barriers","Set","alreadyStarted","upsert","stop","skip","lastStartedState","mem","local","stepn","fullID","has","add","tryRun","exec","removeItem","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","regionStack","forward","normalizeConfig","part","loc","sid","rawConfigA","rawConfigB","thru","observer","stateFirst","storeRef","ref","closure","cb","clone","Object","assign","stateNew","rawShape","isFresh","childRef","field","defaultShape","sidechain","createHook","trigger","acc","hook","forEach","shape","n","mapParams","runnerSteps","attached","runnerFn","states","readStateRef","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","observable","observableItem","disposer","complete","guard","rawName","currentComposite","cases","__"],"mappings":"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"}